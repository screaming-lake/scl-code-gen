{"title": "双字边沿检测", "description": "编写一个函数块FB，该函数块每周期检查一个双字（DWord）输入值中的每一位的上升沿和下降沿。函数块应能够检测并报告输入值中的变化、上升边沿和下降边沿。\n\n示例：\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。", "type": "FUNCTION_BLOCK", "name": "GetBitStates", "input": [{"name": "value", "type": "DWord", "description": "待检查变化和边沿触发的输入值"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "为True时表示输入值已改变"}, {"name": "hasRisingEdges", "type": "Bool", "description": "为True时表示输入值出现上升边沿"}, {"name": "risingBits", "type": "DWord", "description": "上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）"}, {"name": "noOfRisingBits", "type": "USInt", "description": "输入值中的上升边沿数量"}, {"name": "hasFallingEdges", "type": "Bool", "description": "为True时表示输入值出现下降边沿"}, {"name": "fallingBits", "type": "DWord", "description": "下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）"}, {"name": "noOfFallingBits", "type": "USInt", "description": "输入值中的下降边沿数量"}], "answer": "FUNCTION_BLOCK \"GetBitStates\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      value : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      hasChanged  : Bool;\n      hasRisingEdges : Bool;\n      risingBits  : DWord;\n      noOfRisingBits  : USInt;\n      hasFallingEdges  : Bool;\n      fallingBits  : DWord;\n      noOfFallingBits  : USInt;\n   END_VAR\n\n   VAR \n      statPreviousValue  : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempRisingResult : DWord;\n      tempNoRisingBits : DWord;\n      tempFallingResult : DWord;\n      tempNoFallingBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_EDGES : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //============================================================================\n\t  // Title:            GetBitStates\n\t  // Comment/Function: Check DWord for edges, falling as well as rising.  \n\t  //                   Returns the number of edges, DWords with edge bits and a bool if edge(s) exists.\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION PROGRAM LOGIC\n\t  // Get edges from input DWord and DWord from previous cycle\n\t  #tempRisingResult := #value AND NOT #statPreviousValue;\n\t  #tempFallingResult := NOT #value AND #statPreviousValue;\n\t  \n\t  // Store value for next cycle\n\t  #statPreviousValue := #value;\n\t  \n\t  // Copy edge result into work variable for counting the number of rising edges\n\t  #tempNoRisingBits := #tempRisingResult;\n\t  // Count number of rising edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 1) AND 16#55555555));\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 2) AND 16#33333333));\n\t  #tempNoRisingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\t  \n\t  // Copy edges result into work variable for counting the number of falling edges\n\t  #tempNoFallingBits := #tempFallingResult;\n\t  // Count number of falling edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 1) AND 16#55555555));\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 2) AND 16#33333333));\n\t  #tempNoFallingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #hasChanged := (#tempRisingResult > #ZERO_EDGES) OR (#tempFallingResult > #ZERO_EDGES);\n\t  #hasRisingEdges := #tempRisingResult > #ZERO_EDGES;\n\t  #risingBits := #tempRisingResult;\n\t  #noOfRisingBits := DWORD_TO_USINT(#tempNoRisingBits);\n\t  \n\t  #hasFallingEdges := #tempFallingResult > #ZERO_EDGES;\n\t  #fallingBits := #tempFallingResult;\n\t  #noOfFallingBits := DWORD_TO_USINT(#tempNoFallingBits);\n\t  \n\t  // ENO not needed, no error evaluation needed\n\t  ENO := FALSE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "数据类型为DTL的日期时间转换为字符串", "description": "编写一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为YYYY<分隔符>MM<分隔符>DD<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\n\n示例：\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\n函数应返回字符串\"2023-09-17 12:34:56.123456789\"作为转换结果。", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "数据类型为DTL的日期"}, {"name": "separator", "type": "Char", "description": "转换后的日期中年和月之间，以及月和日之间的分隔符"}], "return_value": [{"type": "String", "description": "转换后的日期字符串"}], "answer": "FUNCTION \"DTLToString_ISO\" : String\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      \"date\"  : DTL;\n      separator : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 1;\n      CONVERT_START_POSITION_MONTH : UInt := 6;\n      CONVERT_START_POSITION_DAY : UInt := 9;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            DTLtoString_ISO\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #DTLToString_ISO := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "output": [], "in/out": []}
{"title": "从字符数组中截取字符串", "description": "编写一个函数FC，该函数能够根据给定的起始字符串和结束字符串，从字符数组中截取符合要求的子字符串。\n\n1. 函数应遍历searchIn，查找textBefore首次出现的位置，然后查找随后出现的textAfter的位置。\n2. 如果找到了textBefore和textAfter，函数应截取这两个边界之间的字符串（不包括边界字符串本身），并返回这个子字符串。\n3. 如果textBefore或textAfter在searchIn中不存在，函数应返回特定的状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：输入参数searchIn不是字符数组或字节数组\n\n返回值表示查找的结果：\n- 16#0000：查找成功，头部字符和尾部字符均已找到\n- 16#9001：查找不成功，只找到了起始边界，未找到结束边界\n- 16#9002：查找不成功，起始边界未找到。\n\n示例：\n假设searchIn为\"This is a [sample] string with [multiple] boundaries.\"，textBefore为\"[\"，textAfter为\"]\"。函数应返回\"sample\"作为截取到的子字符串。", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "要截取的字符串的起始边界"}, {"name": "textAfter", "type": "String", "description": "要截取的字符串的结束边界"}], "output": [{"name": "extractedString", "type": "String", "description": "截取的字符串"}, {"name": "status", "type": "Word", "description": "状态代码，具体见说明"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "要在其中进行搜索的字符或字节数组"}], "return_value": [{"type": "Word", "description": "状态代码，具体见说明"}], "answer": "FUNCTION \"ExtractStringFromCharArray\" : Word\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            ExtractStringFromCharArray\n\t  // Function:         The function extracts a String specified by a text before and after\n\t  //                   from an array of characters.\n\t \n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := 0;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to end of text before\n\t      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      \n\t      // Create new string from end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);\n\t        #ExtractStringFromCharArray := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #ExtractStringFromCharArray := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION\n\n"}
{"title": "FIFO先进先出队列", "description": "编写一个函数块FB，实现一个先进先出（FIFO）循环队列的功能，其中队列的最大长度和数据类型都是可变的。循环队列应能够支持以下操作：\n\n1. 入队操作（enqueue）：在队列未满的情况下，将一个元素添加到队列的队尾。\n2. 出队操作（dequeue）：在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n3. 判断队列是否为空：检查队列中是否没有元素。\n4. 判断队列是否已满：检查队列是否已达到最大容量。\n5. 获取队列元素数量：返回队列中当前元素的数量。\n状态代码：\n16#0000：执行FB没有出错\n16#8001：队列是空的\n16#8002：队列是满的", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "入队操作，在队列未满的情况下，将一个元素添加到队列的队尾"}, {"name": "dequeue", "type": "Bool", "description": "出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "clear", "type": "Bool", "description": "清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "initialItem", "type": "Variant", "description": "用于初始化队列的值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}, {"name": "elementCount", "type": "DInt", "description": "队列中元素的数量"}, {"name": "isEmpty", "type": "Bool", "description": "当为TRUE时表示队列是空的"}], "in/out": [{"name": "item", "type": "Variant", "description": "用于加入队列或从队列返回的值"}, {"name": "buffer", "type": "Variant", "description": "用于作为队列的数组"}], "answer": "FUNCTION_BLOCK \"FIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enqueue : Bool := FALSE;\n      dequeue : Bool := FALSE;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      elementCount : DInt := 0;\n      isEmpty : Bool := FALSE;\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statEdgesMem : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      statFirstItemIndex : Int := -1;\n      statNextEmptyItemIndex : Int := 0;\n      statElementCount : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempBufferSize : UDInt;\n      tempCounter : Int;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_FIRST_ENTRY : Word := 16#8611;\n      ERR_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //===============================================================================\n\t    // Title:           FIFO\n\t    // Comment/Function: FIFO (First In First Out)\n\t    //                   Queue / ring buffer memory\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Block execution control\n\t    // collect edges\n\t    #tempEdges.enqueue := #enqueue AND NOT #statEdgesMem.enqueue;\n\t    #tempEdges.dequeue := #dequeue AND NOT #statEdgesMem.dequeue;\n\t    #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t    // store values for edge detection\n\t    #statEdgesMem.enqueue := #enqueue;\n\t    #statEdgesMem.dequeue := #dequeue;\n\t    #statEdgesMem.clear := #clear;\n\t    \n\t    // This program code section is only executed if no trigger input is active\n\t    IF NOT (#enqueue OR #dequeue OR #reset OR #clear) THEN\n\t        // If an error occurred during program execution,\n\t        // the status \"No Current Job\" is used 16#7000 afterwarts when the triggers are reseted\n\t        #error := false;\n\t        #status := #STATUS_NO_CURRENT_JOBS;\n\t        \n\t        // the program processing OF the FB is terminated\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Validation of inputs\n\t    // check whether the ring #buffer is an ARRAY.\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF IS_ARRAY(#buffer) THEN\n\t        #tempBufferSize := CountOfElements(#buffer);\n\t    ELSE\n\t        #error := true;\n\t        #status := #ERR_NO_ARRAY;\n\t        \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the data type OF the ARRAY elements matches\n\t    // the data type OF the entry (#item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the initial value OF the ring #buffer\n\t    // matches the entry (tag #item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the variable indices are within the ARRAY limits.\n\t    // IF they are NOT, the program execution is terminated at this point\n\t    IF (#statNextEmptyItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t        \n\t        RETURN;\n\t    ELSIF (#statFirstItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If resetBuffer is \"TRUE\", the buffer counters are reset\n\t    IF #reset THEN\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t    IF #tempEdges.clear THEN\n\t        FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#tempBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            \n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t        END_FOR;\n\t        \n\t        // checks whether a local error has occurred.\n\t        IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #error := true;\n\t            #status := #ERR_CLEAR_BUFFER;\n\t           \n\t        END_IF;\n\t        \n\t        // reset counters\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION FIFO algorithm  \n\t    IF #tempEdges.dequeue THEN\n\t        REGION dequeue\n\t            // check whether the ring #buffer is empty\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statFirstItemIndex = #BUFFER_IS_EMPTY) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_EMPTY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // return the first entry of the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #statFirstItemIndex,\n\t                                                   DEST_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST => #item);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_RETURN_FIRST_ENTRY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // check whether the ring #buffer contains ARRAY elements\n\t            // IF it does, the first entry is passed further on and the index is incremented BY 1\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statFirstItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_REPLACE_ITEM_BY_INIT_VALUE;\n\t                \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // calculate the new index of the first entry\n\t            #tempNewFirstItemIndex := #statFirstItemIndex + #INCREMENT;\n\t            #tempNewFirstItemIndex := #tempNewFirstItemIndex MOD UDINT_TO_INT(#tempBufferSize);\n\t            \n\t            // check whether the ring buffer is empty\n\t            IF (#statNextEmptyItemIndex = #tempNewFirstItemIndex) THEN\n\t                // If the ring buffer is empty, the index is set to 0\n\t                #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t                #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t            ELSE\n\t                // The index of the first entry is changed\n\t                #statFirstItemIndex := #tempNewFirstItemIndex;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount -= #INCREMENT;\n\t            \n\t        END_REGION dequeue\n\t        \n\t    ELSIF #tempEdges.enqueue THEN\n\t        REGION enqueue\n\t            // check whether the ring #buffer is full\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statNextEmptyItemIndex = #statFirstItemIndex) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_FULL;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // write the entry to the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statNextEmptyItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_WRITE_ENTRY;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // increment the index by 1 and calculates the new empty entry index\n\t            #tempNewNextEmptyItemIndex := (#statNextEmptyItemIndex + #INCREMENT) MOD UDINT_TO_INT(#tempBufferSize);\n\t            #statNextEmptyItemIndex := #tempNewNextEmptyItemIndex;\n\t            \n\t            // check which index the \"#firstItemIndex\" tag has\n\t            // IF the number = -1, the ring buffer is initialized\n\t            // AND the entry is written TO the ring #buffer\n\t            // Therefore, \"0\" must be assigned TO the tag\n\t            IF (#statFirstItemIndex = #BUFFER_INITIALIZED) THEN\n\t                #statFirstItemIndex := #INDEX_BEGINNING;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount += #INCREMENT;\n\t        END_REGION enqueue\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    \n\t    #error := false;\n\t    #status := #STATUS_NO_ERROR;\n\t \n\t    // no error handling by ENO needed\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "计算移动平均值", "description": "编写一个函数块FB，该函数块计算并更新一个移动算术平均值。移动算术平均值是一种在连续数据点上进行平均的方法，其中每个新的数据点都会替换掉最旧的数据点，然后重新计算平均值。\n\n1. cyclicExecution为TRUE时，每个扫描周期自动读取一次新数据value，并更新移动平均值average。\n2. 提供外部触发信号trigger，当触发上升沿时，立即读取一次新数据并更新移动平均值。\n3. 提供复位功能reset，当复位信号为TRUE时，重置移动平均值计算。如果窗口大小小于1或大于100，则输出错误状态和状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：窗口长度设置错误，请设置一个介于1到100之间的值。", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "为TRUE时，周期性读取，trigger不起作用"}, {"name": "trigger", "type": "Bool", "description": "外部触发信号，每次上升沿读取value"}, {"name": "value", "type": "LReal", "description": "新读取的数据值"}, {"name": "windowSize", "type": "Int", "description": "移动平均值的窗口大小，要求范围在1到100之间"}, {"name": "reset", "type": "Bool", "description": "复位信号，当为TRUE时重置移动平均值计算"}], "output": [{"name": "average", "type": "LReal", "description": "移动平均值"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度"}, {"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "answer": "FUNCTION_BLOCK \"FloatingAverage\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      cyclicExecution : Bool := false;\n      trigger : Bool;\n      value : LReal;\n      windowSize : Int := 100;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      average  : LReal;\n      windowSizeReached  : Bool;\n      error  : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR \n      statValues  : Array[#ZERO_INT..#MAX_WINDOW_SIZE] of LReal;\n      statValuesSum  : LReal := 0.0;\n      statArithmeticAverage  : LReal := 0.0;\n      statWindowSizeOld  : Int := 0;\n      statCounter  : Int := 0;\n      statwindowSizeReached  : Bool;\n      statTriggerOld  : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempIndex : Int;\n      tempTriggerEdge : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      MAX_WINDOW_SIZE : Int := 100;\n      INCREMENT : Int := 1;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_WINDOW_SIZE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            FloatingAverage\n\t  // Comment/Function: This function block calculates the floating arithmetic average\n\t  //                   of incoming REAL values each cycle or each trigger impulse.\n\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Copy commonly used data to temp variables\n\t  #tempValue := #value;\n\t  \n\t  // Positive edge detection for triggering of calculation\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerOld;\n\t  #statTriggerOld := #trigger;\n\t  \n\t  // Reset OR if window size changes the calculation\n\t  IF #reset OR (#windowSize <> #statWindowSizeOld) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #windowSizeReached := FALSE;\n\t    #statwindowSizeReached := FALSE;\n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t    \n\t    // Check window size, in case of incorrect window size setup an error\n\t  ELSIF (#windowSize <= #ZERO_INT) OR (#windowSize > #MAX_WINDOW_SIZE) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #statwindowSizeReached := FALSE;\n\t    #windowSizeReached := FALSE;\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_WINDOW_SIZE; // Info \"No correct set of window size\"\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Floating average calculation\n\t  // Triggered calculation OR cyclicly operation\n\t  IF #cyclicExecution OR #tempTriggerEdge THEN\n\t    \n\t    //Calculate array counter by using modulo\n\t    #tempIndex := #statCounter MOD #windowSize;\n\t    \n\t    // First step - fill the Array with values\n\t    // as long as desired window size is not reached\n\t    // counter and array starts with zero\n\t    IF (#statCounter < #windowSize) THEN\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue;\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Increment counter\n\t      #statCounter += #INCREMENT;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #statCounter;\n\t      \n\t    ELSE\n\t      // wuindow size is reached, set output\n\t      #statwindowSizeReached := TRUE;\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue - #statValues[#tempIndex];\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #windowSize;\n\t      \n\t      // Manipulate counter value of window if modulo calc result is zero\n\t      IF (#tempIndex = #ZERO_INT) THEN\n\t        #statCounter := #windowSize + #INCREMENT;\n\t      ELSE\n\t        // Increment counter\n\t        #statCounter += #INCREMENT;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statArithmeticAverage;\n\t  #windowSizeReached := #statwindowSizeReached;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "积分功能", "description": "编写一个函数块FB，该函数块实现输入信号的积分功能，并带有启动和复位功能。积分是对输入信号随时间的累积求和，通常用于计算流量、位移等物理量的累积值。启动功能用于开始积分计算，而复位功能用于将积分值重置为零。\n当读取系统时间出错时，则输出错误状态和错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#8600：读取系统时间错误", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。"}, {"name": "value", "type": "LReal", "description": "需要积分的输入信号值"}, {"name": "reset", "type": "Bool", "description": "复位信号，当该信号为TRUE时，将积分值重置为零"}], "output": [{"name": "integral", "type": "LReal", "description": "积分值"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "answer": "FUNCTION_BLOCK \"Integration\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enable : Bool;\n      value : LReal;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      integral : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR \n      statLastTime  : DTL;\n      statInputOldValue : LReal;\n      statIntegral : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempSysTime  : DTL;\n      tempTimeDiffrence : LReal;\n      tempCalculation : LReal;\n      tempRetval : Word;\n   END_VAR\n\n   VAR CONSTANT \n      CLEAR_TIME  : DTL;\n      SECOND_IN_MS : LReal := 1000.0;\n      DIVIDE_BY_TWO : LReal := 2.0;\n      ZERO : LReal := 0.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_READ_SYS_TIME : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //============================================================================\n\t    // Title:            Integration\n\t    // Comment/Function: Integrates the input value\n\t    //                   integration by trapezoidal rule\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\t//Reset region must be before the enable region so that even if the function disabled, the user can reset the values.\n\tREGION Reset the function\n\t    IF #reset THEN\n\t        #statInputOldValue := #ZERO;\n\t        #statIntegral := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #ZERO;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Reset the function\n\t\n\tREGION Enable/Disable integral calculation\n\t    IF NOT #enable THEN\n\t        #statInputOldValue := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // If it is not cleared when the function is enabled again,\n\t        // the first value will be multiplied with the time difference of the whole disable time\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #statIntegral;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Enable/Disable integral calculation\n\t\n\tREGION Get system time\n\t    // Read system time\n\t    #tempRetval := INT_TO_WORD(RD_SYS_T(OUT => #tempSysTime));\n\t    \n\t    // Error Handling read system time\n\t    IF (#tempRetval > #SUB_STATUS_NO_ERROR) THEN\n\t        #integral := #statIntegral;\n\t        #error := TRUE;\n\t        #status := #ERR_READ_SYS_TIME;\n\t       \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the integral\n\t    // Calculate time difference between last and actual time\n\t    // coverting from DTL via time and DInt to Real\n\t    // scale from millisecond to second\n\t    #tempTimeDiffrence := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #statLastTime))) / #SECOND_IN_MS;\n\t    \n\t    // Write actual to last time\n\t    #statLastTime := #tempSysTime;\n\t    \n\t    // integration by trapezoidal rule\n\t    // add LastScalIn to ScalIn\n\t    // divide by two --> avarage of both - old and actual value\n\t    // multiply with time delta --> area unterneath the both borders\n\t    #tempCalculation := (#value + #statInputOldValue) * #tempTimeDiffrence / #DIVIDE_BY_TWO;\n\t    \n\t    // Calculate new integral\n\t    #statIntegral += #tempCalculation;\n\t    \n\t    // Save last input\n\t    #statInputOldValue := #value;\n\tEND_REGION Calculating the integral\n\t\n\tREGION Write outputs\n\t    #integral := #statIntegral;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    \n\t    \n\t    //ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "灯控程序", "description": "编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "按钮1"}, {"name": "button2", "type": "Bool", "description": "按钮2"}, {"name": "button3", "type": "Bool", "description": "按钮3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿灯"}, {"name": "redLight", "type": "Bool", "description": "红灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄灯"}], "answer": "FUNCTION_BLOCK \"LightsControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      button1 : Bool;\n      button2 : Bool;\n      button3 : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      CycleStep : Int := 0;\n      ManModeTimer1 : TON_TIME;\n      ManModeTimer2 : TON_TIME;\n      AutoModeTimer : TON_TIME;\n   END_VAR\n\n\nBEGIN\n\t    IF #button1 = FALSE THEN\n\t        #ManModeTimer1(IN := #ManModeTimer2.Q,\n\t                       PT := t#1s);\n\t        #ManModeTimer2(IN := NOT #ManModeTimer1.Q,\n\t                       PT := t#1s);\n\t        IF #button2 AND NOT #button3 THEN\n\t            #greenLight := TRUE;\n\t            #redLight := #ManModeTimer2.Q;\n\t            #yellowLight := FALSE;\n\t        ELSIF NOT #button2 AND #button3 THEN\n\t            #redLight := TRUE;\n\t            #yellowLight := #ManModeTimer2.Q;\n\t            #greenLight := FALSE;\n\t        ELSIF #button2 AND #button3 THEN\n\t            #yellowLight := TRUE;\n\t            #greenLight := #ManModeTimer2.Q;\n\t            #redLight := FALSE;\n\t        ELSE\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        END_IF;\n\t        \n\t    ELSE\n\t        #AutoModeTimer(IN := TRUE,\n\t                       PT := T#1s);\n\t        CASE #CycleStep OF\n\t            0:\n\t                #greenLight := TRUE;\n\t                #redLight := FALSE;\n\t                #yellowLight := FALSE;\n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 1;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            1:\n\t                #greenLight := FALSE;\n\t                #redLight := TRUE;\n\t                #yellowLight := FALSE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 2;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            2:\n\t                #greenLight := FALSE;\n\t                #redLight := FALSE;\n\t                #yellowLight := TRUE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 0;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t        END_CASE;\n\t    END_IF;\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "矩阵加法", "description": "编写一个函数FC，实现两个矩阵的加法功能。\n\n该函数接受两个可变长度的二维浮点数数组matrix1和matrix2作为输入参数。函数应检查两个输入矩阵以及用于返回结果的输出矩阵是否具有相同的行数和列数，如果不相同，则返回错误状态和特定的错误代码。\n\n状态代码：\n16#0000：执行FB没有出错\n16#8200：第一矩阵数组行的下界值与第二矩阵行的下界值不同\n16#8201：第一矩阵数组行的下界值与结果矩阵行的下界值不同\n16#8202：第一矩阵数组列的下界值与第二矩阵列的下界值不同\n16#8203：第一矩阵数组列的下界值与结果矩阵列的下界值不同\n16#8204：第一矩阵数组行的上界值与第二矩阵行的上界值不同\n16#8205：第一矩阵数组行的上界值与结果矩阵行的上界值不同\n16#8206：第一矩阵数组列的上界值与第二矩阵列的上界值不同\n16#8207：第一矩阵数组列的上界值与结果矩阵列的上界值不同", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "第一矩阵"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "第二矩阵"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "存放计算结果的矩阵"}], "answer": "FUNCTION \"MatrixAddition\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            MatrixAddition\n\t  // Comment/Function: Caluclates the sum of two matrices\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of all matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Addition of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] + #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "return_value": []}
{"title": "随机数", "description": "编写一个函数FC，该函数使用PLC的时钟值在指定的范围内生成一个随机整数。\n如果指定的范围不正确或读取系统时间出错，则输出错误状态和错误代码。\n\n状态代码\n16#0000：执行FB没有出错\n16#8200：指定的范围不正确：minValue 大于 maxValue\n16#8600：读取系统时间错误", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "随机数范围的最小值"}, {"name": "maxValue", "type": "DInt", "description": "随机数范围的最大值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "DInt", "description": "产生的随机数"}], "answer": "FUNCTION \"RandomRange_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      minValue : DInt;\n      maxValue : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime  : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt := 0;\n      MAX_UDINT : UDInt := 4_294_967_295;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //=============================================================================\n\t    // Title:            RandomRange_DInt\n\t    // Comment/Function: This function generates random numbers in defined limits (Datatype DInt)\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation\n\t    // Check if the maximal Value is less than the minimal value\n\t    IF (#minValue > #maxValue) THEN\n\t        #error := true;\n\t        #status := #ERR_MAX_LESS_MIN;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // Read system time\n\t    #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t    \n\t    // Check return variable for error\n\t    IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t        #error := true;\n\t        #status := #ERR_RD_SYS_T;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t    // Converting to double word so individual bytes can be addressed\n\t    #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t    \n\t    // Callculate a random-start-value depending on the time\n\t    #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t    #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t    #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t    #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t    \n\t    // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t    #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t    \n\t    // Scale the tempNormReal to be in the range of maxValue and minValue\n\t    #RandomRange_DInt := REAL_TO_DINT((#tempNormReal * DINT_TO_REAL(#maxValue - #minValue) + DINT_TO_REAL(#minValue)));\n\t    \n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    \n\t    // ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": []}
{"title": "查找最大最小值", "description": "编写一个函数FC，该函数能够接收一个可变长度的整数数组作为输入，并返回数组中的最大值和最小值以及他们所在数组的位置。\n\n示例：\n假设输入数组为array[1..5]=[5, 10, 2, 25, 1]，函数应返回最大值25，最小值1，最大值所在位置4，最小值所在位置5。", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "待查找的数组"}], "output": [{"name": "minValue", "type": "DInt", "description": "数组中的最小值"}, {"name": "minValueIndex", "type": "DInt", "description": "最小值在数组中的位置"}, {"name": "maxValue", "type": "DInt", "description": "数组中的最大值"}, {"name": "maxValueIndex", "type": "DInt", "description": "最大值在数组中的位置"}], "answer": "FUNCTION \"SearchMinMax_DInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : DInt;\n      minValueIndex : DInt;\n      maxValue : DInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : DInt;\n      tempMinValue : DInt;\n      tempMaxValue : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of double integers\n\t \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  // Assign first value as min / max\n\t  #tempMinValue := #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempArrayIndexMin := #tempArrayIndexMax := #tempArrayLowerBound;\n\t  \n\t  // Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Copy found values to outputs\n\t  // Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  // Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  // Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  // ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": [], "return_value": []}
{"title": "生成脉冲信号", "description": "编写一个函数块FB，该函数块生成一个周期性的信号，该信号在FALSE和TRUE之间变化。每个周期中TRUE状态的持续时间和FALSE状态的持续时间由给定的频率和脉冲间歇比决定。脉冲间歇比定义的是每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。\n\n示例：\n假设frequency为0.5Hz，pulsePauseRatio为3。这意味着每个周期是2秒，其中TRUE状态持续1.5秒，FALSE状态持续0.5秒。", "type": "FUNCTION_BLOCK", "name": "Frequency", "input": [{"name": "frequency", "type": "Real", "description": "以Hz为单位的时钟频率"}, {"name": "pulsePauseRatio", "type": "Real", "description": "脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。"}], "output": [{"name": "clock", "type": "Bool", "description": "脉冲输出"}, {"name": "countdown", "type": "Time", "description": "当前状态的剩余时间"}], "answer": "FUNCTION_BLOCK \"Frequency\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      frequency : Real := 0.0;\n      pulsePauseRatio : Real := 1.0;\n   END_VAR\n\n   VAR_OUTPUT \n      clock  : Bool;\n      countdown  : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse  : TOF_TIME;\n      instTofTimePause  : TOF_TIME;\n      statFrequencyOld  : Real;\n      statPulsePauseRatioOld : Real;\n      statTimePulse  : Time;\n      statTimePause  : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempPulseRate : Real;\n      tempPauseRate : Real;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      SECOND_IN_MS : Real := 1000.0;\n      ONE : Real := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            Frequency\n\t  // Comment/Function: This function generates a signal that changes between the values `FALSE` and `TRUE` depending on a defined frequency and a pulse pause ratio.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF (#frequency <= #ZERO) OR (#pulsePauseRatio <= #ZERO) THEN\n\t    #clock := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    \n\t    //Calculating function frequency and pulse pause ratio only when an input is changed\n\t    IF #statFrequencyOld <> #frequency OR #statPulsePauseRatioOld <> #pulsePauseRatio THEN\n\t      RESET_TIMER(TIMER := #instTofTimePause);\n\t      RESET_TIMER(TIMER := #instTofTimePulse);\n\t      \n\t      #tempPulseRate := #pulsePauseRatio / (#pulsePauseRatio + #ONE); // Calculate pulse rate   \n\t      #tempPauseRate := #ONE - #tempPulseRate;                      // Calculate pause rate   \n\t      #statTimePulse := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPulseRate / #frequency))); // Calculate pulse time   \n\t      #statTimePause := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPauseRate / #frequency))); // Calculate pause time\n\t      #statFrequencyOld := #frequency;\n\t      #statPulsePauseRatioOld := #pulsePauseRatio;\n\t    END_IF;\n\t    \n\t    //Two time off-delay timers that are resetting each other on expiration\n\t    #instTofTimePulse(IN := NOT #instTofTimePause.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    //If timer for pulse is running, remaining time of the PULSE is calculated\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t    \n\t    #instTofTimePause(IN := #instTofTimePulse.Q,\n\t                      PT := #statTimePause);\n\t    \n\t    //If timer for pulse is NOT running, remaining time of the PAUSE is calculated\n\t    IF #tempCountdown = #ZERO_TIME THEN\n\t      #tempCountdown := #statTimePause - #instTofTimePause.ET;\n\t    END_IF;\n\t    \n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse timer to the clock output\n\t  #clock := #instTofTimePulse.Q;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": []}
{"title": "排序", "description": "编写一个函数块FB，实现一个可选的升序或降序排序功能。该函数块应接受一个可变长度的整数数组（最大长度为1000个元素）以及一个指示排序方向的参数（升序或降序），并将排序后的结果写回到原数组中。如果数组元素超过了1000或不超过1个，函数块应输出一个表示错误的状态和一个错误代码。状态代码：\n16#0000：执行FB没有出错\n16#8200：数组元素没超过1个\n16#8201：数组元素超过了1000个", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "当为FALSE时表示升序排列，当为TRUE时表示降序排列"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "待排序的数组"}], "answer": "FUNCTION_BLOCK \"ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "特殊堆栈", "description": "编写一个函数块FB，实现一个特殊堆栈功能，在出栈时移除栈内的最小值。\n1. 入栈操作：当新元素入栈时，首先检查栈是否为满。如果栈为满，则不进行任何操作。否则，将其添加到数组的栈顶位置，并更新栈顶位置。\n2. 出栈操作：当执行出栈操作时，首先检查栈是否为空。如果栈为空，则不进行任何操作。否则，移除栈内的最小值，并返回该元素的值，同时更新栈顶位置。\n状态代码：\n16#0000：执行FB没有出错\n16#8A04：堆栈是满的\n16#8A05：堆栈是空的", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "入栈操作，在栈未满的情况下，将一个元素添加到栈内"}, {"name": "pop", "type": "Bool", "description": "出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，栈顶位置将被重置。"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "item", "type": "Int", "description": "用于入栈或从栈内返回的值"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "用于作为栈的数组"}], "answer": "FUNCTION_BLOCK \"StackMin\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      push : Bool;   // 入栈\n      pop : Bool;   // 出栈\n      reset : Bool;   // 复位\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;   // 故障状态\n      status : Word;   // 状态代码\n   END_VAR\n\n   VAR_IN_OUT \n      item : Int;   // 入栈或出栈的元素\n      stack : Array[0..3] of Int;   // 堆栈空间\n   END_VAR\n\n   VAR \n      statStackIndex : Int;   // 堆栈指针\n      statMin : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempStackSize : DInt;\n      tempCount : Int;\n   END_VAR\n\n   VAR CONSTANT \n      STACK_FULL : Word := 16#8A04;   // 堆栈已满\n      STACK_EMPTY : Word := 16#8A05;   // 堆栈已空\n      NO_ERROR : Word := 16#0000;\n   END_VAR\n\n\nBEGIN\n\t//设置堆栈长度\n\tREGION StackSize\n\t    #tempStackSize := 4;\n\tEND_REGION\n\t\n\t//入栈\n\tREGION Push\n\t    IF #push = TRUE THEN\n\t        IF #statStackIndex >= #tempStackSize THEN             //判断是否满栈，如果已经满栈,则不执行入栈,并报错\n\t            #error := TRUE;\n\t            #status := #STACK_FULL;\n\t            RETURN;\n\t        END_IF;\n\t        #stack[#statStackIndex] := #item;                    //否则放入元素\n\t        #statStackIndex += 1;                                //堆栈指针上移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//出栈\n\tREGION Pop\n\t    IF #pop = TRUE THEN\n\t        \n\t        //判断空栈，如果已经空栈,则不执行出栈,并报错\n\t        IF #statStackIndex <= 0 THEN                          \n\t            #error := TRUE;\n\t            #status := #STACK_EMPTY;\n\t            RETURN;\n\t        END_IF;\n\t        \n\t        //查找最小值所在位置\n\t        #statMin := 0;\n\t        IF #statStackIndex>1 THEN\n\t            FOR #tempCount := 1 TO #statStackIndex - 1 DO\n\t                IF #stack[#tempCount] < #stack[#statMin] THEN\n\t                    #statMin := #tempCount;\n\t                END_IF;\n\t            END_FOR;\n\t        END_IF;\n\t        \n\t        //取出元素，上面元素往下顺移\n\t        #item := #stack[#statMin];               \n\t        IF #statMin<>#statStackIndex-1 THEN\n\t            FOR #tempCount := #statMin TO #statStackIndex - 2 DO\n\t                #stack[#tempCount] := #stack[#tempCount + 1];\n\t            END_FOR;\n\t        END_IF;\n\t        #stack[#statStackIndex - 1] := 0;\n\t        #statStackIndex -= 1;                               //堆栈指针下移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//复位\n\tREGION Reset\n\t    IF #reset = TRUE THEN\n\t        #statStackIndex := 0;\n\t    END_IF;\n\tEND_REGION\n\t\n\t#error := FALSE;\n\t#status := #NO_ERROR;\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": []}
{"title": "字符串转换为IP地址和端口号", "description": "在西门子PLC编程中，经常需要从用户输入或外部设备接收包含IP地址和端口号的字符串，并将其解析为相应的整数格式以便进行网络通信。\n编写一个函数FC，用于将包含IP地址和可能包含端口号的字符串转换为整数形式的IP地址和端口号。字符串的格式应为\"xxx.xxx.xxx.xxx[:port]\"，其中xxx代表0-255之间的数字，port代表0-65535之间的端口号（可选）。如果字符串包含端口号，则同时返回端口号；如果不包含，则返回默认的端口号（比如0）。把转换后的IP地址和端口号返回给系统数据类型TADDR_Param结构体的相应位置。\n函数应检查输入字符串是否符合\"IP_ADDRESS:PORT\"的格式要求，其中IP地址由四个用点分隔的0到255之间的整数组成，端口号为一个0到65535之间的整数。\n如果字符串格式正确，函数应将其解析为四个字节的整数数组表示的IP地址和一个整数表示的端口号，并将这些值返回。\n如果字符串格式不正确，函数应输出一个表示错误的状态和一个错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#811x：IP地址含有过多字符，其中x表示出错的最低字节序号，例如，IP地址的第2个字节有错，则x=2\n16#812x：IP地址字符串是空字符串，x表示的含义同上\n16#813x：超过IP地址最大值（255），x表示的含义同上\n16#8150：端口号字符过多\n16#8151：端口号字符串为空\n16#8152：超过端口号最大值（65535）", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "输入的字符串"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "TADDR_Param", "description": "转换后的IP地址和端口号"}], "answer": "FUNCTION \"StringToTaddr\" : TADDR_Param\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      ipAddressString : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempOctetIndex : Int;\n      tempCharPosition : Int;\n      tempAddressString : String;\n      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];\n      tempNumber : UDInt;\n      tempPortNumberIsSpecified : Bool;\n      tempIpAdressTaddr  : TADDR_Param;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;\n      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;\n      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;\n      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;\n      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;\n      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;\n      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;\n      MAX_PORT_NUMBER : UInt := 65535;\n      EMPTY_STRING : Int := 0;\n      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;\n      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;\n      INIT_VAL : USInt := 0;\n      NUMBER_OF_IP_OCTETS : Int := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            StringToTaddr\n\t  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  #tempAddressString := #ipAddressString;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\tEND_REGION\n\t\n\tREGION Process Address String  \n\t  REGION Process octests 1-4\n\t    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO\n\t      // check if loop has not reached the last octet\n\t      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN\n\t        // search for dot as octet seperator\n\t        // there has to be a dot present between the octets\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);\n\t        \n\t      ELSE\n\t        // search for colon as port seperator after the last Octet\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);\n\t        \n\t        // if colon is present, there is a port number specified / check if Port number added\n\t        #tempPortNumberIsSpecified := (#tempCharPosition > 0);\n\t        \n\t        // if no port is spezified, its just the last octet\n\t        IF NOT #tempPortNumberIsSpecified THEN\n\t          // need to set the char position to the end of string + one for later cobesion and checks\n\t          #tempCharPosition := LEN(#tempAddressString) + 1;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      REGION Octet conversion\n\t        // check if IP Octet contains more then three digits --> Error\n\t        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // extract octet string\n\t        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);\n\t        // Check if Octet string is empty --> Error\n\t        IF LEN(#tempOctetString) = #EMPTY_STRING THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // Convert the octet string to numerical value\n\t        STRG_VAL(IN     := #tempOctetString,\n\t                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t                 P      := #CONVERT_START_POSITION,\n\t                 OUT    => #tempNumber);\n\t        \n\t        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error\n\t        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // add address octet to temp address tag\n\t        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);\n\t        \n\t        // delete octet string from address string\n\t        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);\n\t      END_REGION Octet conversion\n\t    END_FOR;\n\t  END_REGION Process octests 1-4\n\t  \n\t  REGION PORT number conversion\n\t    // If the string contains a port number too, parse it\n\t    IF #tempPortNumberIsSpecified THEN\n\t      // lenght of string exceeds length of port string --> Error\n\t      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t        \n\t        // Check if string is empty --> Error\n\t      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_STRING_IS_EMPTY;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // Convert the port number string to numerical value\n\t      STRG_VAL(IN     := #tempAddressString,\n\t               FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t               P      := #CONVERT_START_POSITION,\n\t               OUT    => #tempNumber);\n\t      \n\t      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error\n\t      IF #tempNumber > #MAX_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_EXCEEDS_MAX_PORT;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // add port number to temp address tag\n\t      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);\n\t    END_IF;\n\t  END_REGION PORT number conversion\n\t  \n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": []}
{"title": "温度逻辑控制", "description": "编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "温度传感器输入值，即实际温度"}, {"name": "SetTemperature", "type": "Real", "description": "设定温度值"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "当前温度显示"}, {"name": "SetTempDisplay", "type": "Real", "description": "设定温度显示"}, {"name": "HeaterStatus", "type": "Bool", "description": "加热器状态显示"}, {"name": "OverheatProtection", "type": "Bool", "description": "过热保护状态显示"}], "in/out": [{"name": "HeaterOutput", "type": "Bool", "description": "加热器控制输出"}], "answer": "FUNCTION_BLOCK \"TempCtrl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      TemperatureSensorInput : Real;   // 温度传感器输入值\n      SetTemperature : Real;   // 设定温度值\n   END_VAR\n\n   VAR_OUTPUT \n      CurrentTemperature : Real;   // 当前温度显示\n      SetTempDisplay : Real;   // 设定温度显示\n      HeaterStatus : Bool;   // 加热器状态显示\n      OverheatProtection : Bool;   // 过热保护状态显示\n   END_VAR\n\n   VAR_IN_OUT \n      HeaterOutput : Bool;   // 加热器控制输出\n   END_VAR\n\n   VAR \n      HeaterState : Struct\n         IsEnabled : Bool;\n         OverheatProtectionTriggered : Bool;\n      END_STRUCT;\n      OverheatTimer  : TON_TIME;   // 过热保护定时器\n      SensorError : Bool;   // 传感器错误标志\n      CoolTimer  : TON_TIME;\n      OverheatTimerOutput  : Bool;\n      CoolTimerOutput  : Bool;\n   END_VAR\n\n\nBEGIN\n\t// 显示当前温度和设定温度 \n\t#CurrentTemperature := #TemperatureSensorInput;\n\t#SetTempDisplay := #SetTemperature;\n\t\n\t// 检查传感器是否失效 \n\tIF #TemperatureSensorInput < 0 OR #TemperatureSensorInput > 100 THEN\n\t    #SensorError := TRUE;\n\tELSE\n\t    #SensorError := FALSE;\n\tEND_IF;\n\t\n\t// 温度控制逻辑 \n\t// 过热保护逻辑 \n\t#OverheatTimer(IN := #HeaterOutput,\n\t               PT := T#5S,\n\t               Q => #OverheatTimerOutput);\n\tIF #HeaterState.IsEnabled AND #OverheatTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := TRUE;\n\t    #HeaterState.IsEnabled := FALSE;\n\t    #HeaterOutput := FALSE;\n\tEND_IF;\n\t#CoolTimer(IN := #HeaterState.OverheatProtectionTriggered,\n\t           PT := t#3S,\n\t           Q => #CoolTimerOutput);\n\tIF #CoolTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := FALSE ;\n\tEND_IF;\n\t\n\tIF NOT #SensorError THEN\n\t    IF #CurrentTemperature < #SetTemperature AND NOT #HeaterState.OverheatProtectionTriggered THEN\n\t        IF NOT #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := TRUE;\n\t            #HeaterOutput := TRUE;\n\t        END_IF;\n\t    ELSIF #CurrentTemperature > #SetTemperature THEN\n\t        IF #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := FALSE;\n\t            #HeaterOutput := FALSE;\n\t        END_IF;\n\t    END_IF;\n\t    \n\tELSE\n\t    // 传感器错误处理 \n\t    #HeaterOutput := FALSE;\n\t    #HeaterState.IsEnabled := FALSE;\n\tEND_IF;\n\t\n\t// 显示加热器状态和过热保护状态 \n\t#HeaterStatus := #HeaterState.IsEnabled;\n\t#OverheatProtection := #HeaterState.OverheatProtectionTriggered;\nEND_FUNCTION_BLOCK\n\n", "return_value": []}

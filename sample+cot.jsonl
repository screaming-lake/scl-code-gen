{"title": "自动化灌装生产线控制", "description": "一个自动化灌装生产线负责对瓶子进行清洗、灌装、封盖和包装。生产线的每个步骤都由PLC控制，并且由传感器和操作员的输入信号触发。\n控制要求：\n当传感器bottleSensor检测到瓶子时，触发清洗泵启动并持续工作。\n清洗完成后，由操作员操作按钮cleaningConfirmButton触发清洗完成信号，自动启动灌装阀进行灌装。\n灌装完成后，由操作员操作按钮fillingConfirmButton触发灌装完成信号，自动启动封盖机进行封盖。\n封盖完成后，由操作员操作按钮cappingConfirmButton触发封盖完成信号，启动包装机进行包装。\n包装完成后，由操作员操作按钮packingConfirmButton触发包装完成信号，点亮包装完成指示灯。\n操作员取走包装好的瓶子后，按下确认按钮finishedButton复位指示灯，并为下一个瓶子的生产循环做准备。", "type": "FUNCTION_BLOCK", "name": "FB_BottleProcessing", "input": [{"name": "bottleSensor", "type": "Bool", "description": "瓶子到达传感器，检测到瓶子时触发信号"}, {"name": "cleaningConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认清洗工序完成"}, {"name": "fillingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认灌装工序完成"}, {"name": "cappingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认封盖工序完成"}, {"name": "packingConfirmButton", "type": "Bool", "description": "操作员确认按钮，用于确认包装工序完成"}, {"name": "finishedButton", "type": "Bool", "description": "操作员确认按钮，用于确认瓶子已取走"}], "output": [{"name": "Pump_Motor", "type": "Bool", "description": "控制清洗泵电机的运行输出"}, {"name": "Filling_Valve", "type": "Bool", "description": "控制灌装阀的运行输出"}, {"name": "Capping_Machine", "type": "Bool", "description": "控制封盖机的运行输出"}, {"name": "Packing_Machine", "type": "Bool", "description": "控制包装机的运行输出"}, {"name": "Completion_Light", "type": "Bool", "description": "包装完成指示灯"}], "in/out": [], "return_value": [], "ID": 0, "is_sample": false, "cot": "1. 检测到瓶子，启动清洗泵\n2. 清洗完成，启动灌装阀\n3. 灌装完成，启动封盖机\n4. 封盖完成，启动包装机\n5. 包装完成，点亮指示灯\n6. 确认瓶子已取走，复位指示灯\n7. 注意：TRUE和FALSE为内置Bool类型变量的值，不需要定义。\n8. 注意：所有的变量必须先赋值再使用，不得使用未赋值的变量。在VAR中定义变量的同时必须进行赋初值，例如：\n```scl\nVAR \n    a : Bool := FALSE;\nEND_VAR", "answer": "FUNCTION_BLOCK \"FB_BottleProcessing\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      bottleSensor : Bool;\n      cleaningConfirmButton : Bool;\n      fillingConfirmButton : Bool;\n      cappingConfirmButton : Bool;\n      packingConfirmButton : Bool;\n      finishedButton : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      Pump_Motor : Bool;\n      Filling_Valve : Bool;\n      Capping_Machine : Bool;\n      Packing_Machine : Bool;\n      Completion_Light : Bool;\n   END_VAR\n\n   VAR \n      statBottleDetected : Bool := FALSE;\n      statCleaningFinished : Bool := FALSE;\n      statFillingFinished : Bool := FALSE;\n      statCappingFinished : Bool := FALSE;\n      statPackingFinished : Bool := FALSE;\n   END_VAR\n\n\nBEGIN\n\t// 检测到瓶子\n\tIF #bottleSensor AND NOT #statBottleDetected THEN\n\t    #statBottleDetected := TRUE;\n\t    #Pump_Motor := TRUE;\n\tEND_IF;\n\t\n\t// 清洗完成确认\n\tIF #cleaningConfirmButton AND #statBottleDetected THEN\n\t    #statCleaningFinished := TRUE;\n\t    #Pump_Motor := FALSE;\n\t    #Filling_Valve := TRUE;\n\tEND_IF;\n\t\n\t// 灌装完成确认\n\tIF #fillingConfirmButton AND #statCleaningFinished THEN\n\t    #statFillingFinished := TRUE;\n\t    #Filling_Valve := FALSE;\n\t    #Capping_Machine := TRUE;\n\tEND_IF;\n\t\n\t// 封盖完成确认\n\tIF #cappingConfirmButton AND #statFillingFinished THEN\n\t    #statCappingFinished := TRUE;\n\t    #Capping_Machine := FALSE;\n\t    #Packing_Machine := TRUE;\n\tEND_IF;\n\t\n\t// 包装完成确认\n\tIF #packingConfirmButton AND #statCappingFinished THEN\n\t    #statPackingFinished := TRUE;\n\t    #Packing_Machine := FALSE;\n\t    #Completion_Light := TRUE;\n\tEND_IF;\n\t\n\t// 包装完成指示灯复位\n\tIF #finishedButton AND #statPackingFinished THEN\n\t    #statBottleDetected := FALSE;\n\t    #statCleaningFinished := FALSE;\n\t    #statFillingFinished := FALSE;\n\t    #statCappingFinished := FALSE;\n\t    #statPackingFinished := FALSE;\n\t    #Completion_Light := FALSE;\n\tEND_IF;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        bottleSensor : Bool;    //瓶子到达传感器，检测到瓶子时触发信号\n        cleaningConfirmButton : Bool;    //操作员确认按钮，用于确认清洗工序完成\n        fillingConfirmButton : Bool;    //操作员确认按钮，用于确认灌装工序完成\n        cappingConfirmButton : Bool;    //操作员确认按钮，用于确认封盖工序完成\n        packingConfirmButton : Bool;    //操作员确认按钮，用于确认包装工序完成\n        finishedButton : Bool;    //操作员确认按钮，用于确认瓶子已取走\n    END_VAR\n\n    VAR_OUTPUT\n        Pump_Motor : Bool;    //控制清洗泵电机的运行输出\n        Filling_Valve : Bool;    //控制灌装阀的运行输出\n        Capping_Machine : Bool;    //控制封盖机的运行输出\n        Packing_Machine : Bool;    //控制包装机的运行输出\n        Completion_Light : Bool;    //包装完成指示灯\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "计算一年中的第几天", "description": "在某些自动化系统中，可能需要根据当前日期计算出它是一年中的第几天。这可以用于追踪生产周期、维护计划或其他需要日期信息的场合。\n控制要求：\n系统需要接收日期输入，包括年、月、日。\n根据输入的日期，计算并输出它是一年中的第几天。\n考虑到不同年份的2月天数可能不同（平年28天，闰年29天），系统需要能够识别闰年并相应地计算。\n输出结果应该是一个整数，表示一年中的第几天。\n如果输入的日期不合法（如2月30日、4月31日等），系统应输出错误状态和错误代码。\n说明：\n1. 要求输入的年份Year在1000到3000之间（包括1000和3000），否则输出错误状态error=true和错误代码status=16#8001。如果输入的月份Month不合法，则输出错误状态error=true和错误代码status=16#8002。如果输入的日Day不合法，则输出错误状态error=true和错误代码status=16#8003。\n2. 计算的结果通过DayOfYear输出。", "type": "FUNCTION_BLOCK", "name": "FB_CalculateDayOfYear", "input": [{"name": "Year", "type": "Int", "description": "年份输入"}, {"name": "Month", "type": "Int", "description": "月份输入"}, {"name": "Day", "type": "Int", "description": "日输入"}], "output": [{"name": "DayOfYear", "type": "Int", "description": "一年中的第几天输出"}, {"name": "error", "type": "Bool", "description": "错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [], "return_value": [], "ID": 1, "is_sample": false, "cot": "1. 首先，检查输入的年份、月份和日期是否合法。如果不合法，设置错误状态和错误代码，然后退出。\n2. 然后，根据输入的年份判断是否为闰年。如果是闰年，2月有29天，否则有28天。\n3. 最后，根据输入的月份和日期，计算出这是一年中的第几天。\n4. 注意：若需要使用STATUS_FINISHED_NO_ERROR等变量，需要先在VAR CONSTANT中定义，不得使用未被定义过的变量。\n5. 注意：数组的赋值要在声明的时候，也就是说定义和赋值均在VAR中，不得在代码段中赋值, 也不得在VAR CONSTANT中定义和赋值。正确示例如下：\n```scl\nVAR\n    A : ARRAY[1..10] OF Int := [1,1,1,1,1,1,1,1,1,1];\nEND_VAR\n```\n6. 注意：程序中不得使用SUM函数，scl语言不支持该函数。\n7. 注意：程序中循环变量不得使用Month，该变量是程序的输入变量，不得作为循环变量。需要重新定义一个循环变量，例如i。\n8. 注意：需要先判断闰年，然后再判断输入日Day是否合法，若为闰年，首先需要修改之前定义的数组，然后再检查输入日Day是否合法。\n", "answer": "FUNCTION_BLOCK \"FB_CalculateDayOfYear\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT\n      Year : Int;\n      Month : Int;\n      Day : Int;\n   END_VAR\n\n   VAR_OUTPUT\n      DayOfYear : Int;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR\n      daysPerMonth : Array[1..12] of Int := [31, 28, 31, 30, 31, 30, 31, 31, 30, 31, 30, 31];\n   END_VAR\n\n   VAR_TEMP\n      isLeapYear : Bool;\n      tempMonth : Int;\n   END_VAR\n\n   VAR CONSTANT\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_INVALID_YEAR : Word := 16#8001;\n      ERR_INVALID_MONTH : Word := 16#8002;\n      ERR_INVALID_DAY : Word := 16#8003;\n   END_VAR\n\n\nBEGIN\n\t// Check if year is within valid range\n\tIF (#Year < 1000) OR (#Year > 3000) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_YEAR;\n\t  RETURN;\n\tEND_IF;\n\n\t// Check if month is valid\n\tIF (#Month < 1) OR (#Month > 12) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_MONTH;\n\t  RETURN;\n\tEND_IF;\n\n\t// Check for leap year\n\t#isLeapYear := (#Year MOD 4 = 0) AND (#Year MOD 100 <> 0) OR (#Year MOD 400 = 0);\n\tIF #isLeapYear THEN\n\t  #daysPerMonth[2] := 29;\n\tEND_IF;\n\n\t// Check if day is valid\n\tIF (#Day < 1) OR (#Day > #daysPerMonth[#Month]) THEN\n\t  #error := TRUE;\n\t  #status := #ERR_INVALID_DAY;\n\t  RETURN;\n\tEND_IF;\n\n\t// Calculate DayOfYear\n\t#DayOfYear := 0;\n\tFOR #tempMonth := 1 TO #Month - 1 DO\n\t  #DayOfYear += #daysPerMonth[#tempMonth];\n\tEND_FOR;\n\t#DayOfYear += #Day;\n\n\t// Set outputs\n\t#error := FALSE;\n\t#status := #STATUS_NO_ERROR;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        Year : Int;    //年份输入\n        Month : Int;    //月份输入\n        Day : Int;    //日输入\n    END_VAR\n\n    VAR_OUTPUT\n        DayOfYear : Int;    //一年中的第几天输出\n        error : Bool;    //错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "控制台指示灯顺序控制", "description": "某控制台装有3个指示灯，分别为绿色、红色和黄色。需要通过一个控制按钮来循环控制这些灯的状态。\n控制要求：\n使用一个输入参数controlButton表示控制按钮的状态，该按钮为脉冲信号，每次触发时产生一个从0到1的跳变。\n使用三个输出参数greenLight、redLight、yellowLight分别来控制对应的绿色、红色和黄色指示灯。\n控制按钮触发的顺序和对应指示灯的状态如下：\n第1次触发：只有绿灯greenLight亮。\n第2次触发：只有红灯redLight亮。\n第3次触发：只有黄灯yellowLight亮。\n第4次触发：3个灯都亮。\n第5次触发：3个灯都灭。\n第6次触发及以后：重复上述循环。", "type": "FUNCTION_BLOCK", "name": "FB_ColorLightControl", "input": [{"name": "controlButton", "type": "Bool", "description": "控制按钮开关，脉冲信号"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿色指示灯"}, {"name": "redLight", "type": "Bool", "description": "红色指示灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄色指示灯"}], "in/out": [], "return_value": [], "ID": 2, "is_sample": false, "cot": "1. 定义一个变量count来记录控制按钮的触发次数。\n2. 当控制按钮从0变为1时，count加1。\n3. 根据count的值来控制指示灯的状态。\n4. 注意：Int类型变量不得与Bool类型变量直接运算，仅允许Bool类型变量与Bool类型变量进行And运算。\n5. 注意：为了实现对脉冲信号的检测，需要定义一个Bool类型的变量PrecontrolButton，并赋初值FALSE，然后与controlButton变量配合共同实现脉冲检测的功能。\n", "answer": "﻿FUNCTION_BLOCK \"FB_ColorLightControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      controlButton : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      StepCounter : Int := 0;\n      LastButtonState : Bool := FALSE;\n   END_VAR\n\n\nBEGIN\n\t// Check if the control button was pressed (rising edge)\n\tIF (#controlButton AND NOT #LastButtonState) THEN\n\t    // Increment the step counter\n\t    #StepCounter := #StepCounter + 1;\n\t    \n\t    // If the step counter exceeds 5, reset it to 1\n\t    IF (#StepCounter > 5) THEN\n\t        #StepCounter := 1;\n\t    END_IF;\n\t    \n\t    // Update the light states based on the step counter\n\t    CASE #StepCounter OF\n\t        1:\n\t            #greenLight := TRUE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        2:\n\t            #greenLight := FALSE;\n\t            #redLight := TRUE;\n\t            #yellowLight := FALSE;\n\t        3:\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := TRUE;\n\t        4:\n\t            #greenLight := TRUE;\n\t            #redLight := TRUE;\n\t            #yellowLight := TRUE;\n\t        5:\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t    END_CASE;\n\tEND_IF;\n\t\n\t// Update the last button state\n\t#LastButtonState := #controlButton;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        controlButton : Bool;    //控制按钮开关，脉冲信号\n    END_VAR\n\n    VAR_OUTPUT\n        greenLight : Bool;    //绿色指示灯\n        redLight : Bool;    //红色指示灯\n        yellowLight : Bool;    //黄色指示灯\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "PLC数据库数据存储与管理系统", "description": "在一些自动化应用中，PLC需要收集和存储大量的数据，例如传感器读数、生产计数或其他过程变量。这些数据通常存储在PLC的内部数据库或外部数据库系统中。\n控制要求：\n系统需要接收一组数据dataInput，以字节数组构建，这组数据的第一个字节dataInput[0]表示要存入的数据字节长度。\n数据的存储操作由输入storeTrigger触发。\n数据需要依次存入数据库，每组数据长度可能不同。\n当数据库剩余空间不足以存入新的一组数据时，系统应触发报错error。\n系统应提供一个复位功能，通过输入resetTrigger来清空数据库，并重置error。\n系统应能够输出数据库的当前使用情况和剩余空间。\n说明：\n1. 当存储信号storeTrigger触发时，首先检查数据输入长度信息（即数组的首字节dataInput[0]）是否非法，如果小于等于0或大于5，则输出错误状态error=true和错误代码status=16#8001。如果数据库剩余空间不足以存入新数据，则输出错误状态error=true和错误代码status=16#8002。如果没有这些错误，则根据长度信息，把从输入数组的第二字节开始的数据取出，并存入数据库。存入时不能覆盖数据库原有的数据，从原有数据之后依次存入。\n2. 当复位信号resetTrigger触发时，清空数据库中所有数据，并复位错误状态error=0和status=0。\n3. 数据库已使用空间和剩余空间分别通过usedSpace和remainingSpace输出。", "type": "FUNCTION_BLOCK", "name": "FB_DatabaseManager", "input": [{"name": "dataInput", "type": "Array[0..5] of Byte", "description": "数据输入，字节数组"}, {"name": "storeTrigger", "type": "Bool", "description": "存储触发信号"}, {"name": "resetTrigger", "type": "Bool", "description": "复位触发信号"}], "output": [{"name": "usedSpace", "type": "Int", "description": "数据库已使用空间"}, {"name": "remainingSpace", "type": "Int", "description": "数据库剩余空间"}, {"name": "error", "type": "Bool", "description": "错误状态指示 FALSE:没有发生错误 TRUE:执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "dataBase", "type": "Array[1..20] of Byte", "description": "数据库，字节数组"}], "return_value": [], "ID": 3, "is_sample": false, "cot": "1. 检查存储触发信号storeTrigger，如果为真，执行存储操作。\n2. 检查数据输入长度信息，如果小于等于0或大于5，输出错误状态和错误代码。\n3. 检查数据库剩余空间，如果不足以存入新数据，输出错误状态和错误代码。\n4. 如果没有错误，从输入数组的第二字节开始，取出数据并存入数据库。\n5. 检查复位触发信号resetTrigger，如果为真，清空数据库并复位错误状态。\n6. 输出数据库已使用空间和剩余空间。\n\n", "answer": "FUNCTION_BLOCK \"FB_DatabaseManager\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      dataInput : Array[0..5] of Byte;\n      storeTrigger : Bool;\n      resetTrigger : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      usedSpace : Int;\n      remainingSpace : Int;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      dataBase : Array[1..20] of Byte;\n   END_VAR\n\n   VAR \n      statDataBaseIndex : Int := 1;\n      statError : Bool;\n      statStatus : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempDataLength : Int;\n      tempDataIndex : Int;\n   END_VAR\n\n   VAR CONSTANT \n      DATABASE_SIZE : Int := 20;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_ILLEGAL_DATA_LENGTH : Word := 16#8001;\n      STATUS_DATABASE_FULL : Word := 16#8002;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            FB_DatabaseManager\n\t  // Comment/Function: PLC database data storage and management system\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization and input data processing\n\t  // Reset the database when the reset trigger is activated\n\t  IF #resetTrigger THEN\n\t    #statDataBaseIndex := 1;\n\t    #statError := false;\n\t    #statStatus := #STATUS_NO_ERROR;\n\t    \n\t    FOR #tempDataIndex := 1 TO #DATABASE_SIZE DO\n\t      #dataBase[#tempDataIndex] := 0;\n\t    END_FOR;\n\t    \n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Data storage\n\t  // Check if the store trigger is activated\n\t  IF #storeTrigger THEN\n\t    \n\t    // Read the data length from the first byte of the input array\n\t    #tempDataLength := #dataInput[0];\n\t    \n\t    // Check if the data length is illegal\n\t    IF (#tempDataLength <= 0) OR (#tempDataLength > 5) THEN\n\t      #statError := true;\n\t      #statStatus := #STATUS_ILLEGAL_DATA_LENGTH;\n\t      \n\t      RETURN;\n\t    END_IF;\n\t    \n\t    // Check if there is enough space in the database\n\t    IF (#statDataBaseIndex + #tempDataLength - 1 > #DATABASE_SIZE) THEN\n\t      #statError := true;\n\t      #statStatus := #STATUS_DATABASE_FULL;\n\t      \n\t      RETURN;\n\t    END_IF;\n\t    \n\t    // Store the data in the database\n\t    FOR #tempDataIndex := 1 TO #tempDataLength DO\n\t      #dataBase[#statDataBaseIndex] := #dataInput[#tempDataIndex];\n\t      #statDataBaseIndex += 1;\n\t    END_FOR;\n\t    \n\t    // Update the error and status\n\t    #statError := false;\n\t    #statStatus := #STATUS_NO_ERROR;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  // Calculate the used and remaining space\n\t  #usedSpace := #statDataBaseIndex - 1;\n\t  #remainingSpace := #DATABASE_SIZE - #usedSpace;\n\t  \n\t  // Update the error and status outputs\n\t  #error := #statError;\n\t  #status := #statStatus;\n\t  \n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        dataInput : Array[0..5] of Byte;    //数据输入，字节数组\n        storeTrigger : Bool;    //存储触发信号\n        resetTrigger : Bool;    //复位触发信号\n    END_VAR\n\n    VAR_OUTPUT\n        usedSpace : Int;    //数据库已使用空间\n        remainingSpace : Int;    //数据库剩余空间\n        error : Bool;    //错误状态指示 FALSE:没有发生错误 TRUE:执行出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        dataBase : Array[1..20] of Byte;    //数据库，字节数组\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "浮点数区间线性化转换", "description": "在一些自动化控制系统中，可能需要将一个物理量（如温度、压力等）的测量值转换为另一个线性化或标准化的值，以便于控制算法的处理或显示。例如，一个传感器测量的物理量可能在特定的非线性区间内变化，但控制系统需要一个线性化的值来进行计算。\n控制要求：\n系统需要接收一个浮点数作为输入，表示原始测量值。\n根据输入值的大小，将其转换到不同的线性区间，输出转换后的线性化值。\n当输入值在1200到3600之间，则转换到150到240之间。\n当输入值在3600到4800之间，则转换到240到560之间。\n当输入值在4800到7000之间，则转换到560到720之间。\n如果输入值小于1200或大于7000，则转换后的值应为1200或7000对应的线性化值，并输出错误状态error=1，status=16#8001。", "type": "FUNCTION_BLOCK", "name": "FB_LinearizeValue", "input": [{"name": "InputValue", "type": "Real", "description": "浮点数输入，原始测量值"}], "output": [{"name": "LinearizedValue", "type": "Real", "description": "转换后的线性化值"}, {"name": "Error", "type": "Bool", "description": "错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错"}, {"name": "Status", "type": "Word", "description": "状态代码"}], "in/out": [], "return_value": [], "ID": 4, "is_sample": false, "cot": "1. 判断输入值的大小，根据不同的区间进行不同的线性化转换。\n2. 如果输入值小于1200或大于7000，则转换后的值应为1200或7000对应的线性化值，并输出错误状态error=1，status=16#8001。\n3. 输出转换后的线性化值。\n\n", "answer": "FUNCTION_BLOCK \"FB_LinearizeValue\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      InputValue : Real;\n   END_VAR\n\n   VAR_OUTPUT \n      LinearizedValue : Real;\n      Error : Bool;\n      Status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempInputValue : Real;\n      tempSlope1 : Real;\n      tempSlope2 : Real;\n      tempSlope3 : Real;\n      tempIntercept1 : Real;\n      tempIntercept2 : Real;\n      tempIntercept3 : Real;\n   END_VAR\n\n   VAR CONSTANT \n      INPUT_MIN : Real := 1200.0;\n      INPUT_MAX : Real := 7000.0;\n      INPUT_RANGE1 : Real := 2400.0;\n      INPUT_RANGE2 : Real := 1200.0;\n      INPUT_RANGE3 : Real := 2200.0;\n      OUTPUT_MIN : Real := 150.0;\n      OUTPUT_MAX : Real := 720.0;\n      OUTPUT_RANGE1 : Real := 90.0;\n      OUTPUT_RANGE2 : Real := 320.0;\n      OUTPUT_RANGE3 : Real := 160.0;\n      STATUS_ERROR : Word := 16#8001;\n   END_VAR\n\n\nBEGIN\n\t// 初始化临时变量\n\t#tempInputValue := #InputValue;\n\t#tempSlope1 := #OUTPUT_RANGE1 / #INPUT_RANGE1;\n\t#tempSlope2 := #OUTPUT_RANGE2 / #INPUT_RANGE2;\n\t#tempSlope3 := #OUTPUT_RANGE3 / #INPUT_RANGE3;\n\t#tempIntercept1 := #OUTPUT_MIN - (#tempSlope1 * #INPUT_MIN);\n\t#tempIntercept2 := #OUTPUT_MIN - (#tempSlope2 * #INPUT_MIN);\n\t#tempIntercept3 := #OUTPUT_MAX - (#tempSlope3 * #INPUT_MAX);\n\t\n\t// 线性化转换\n\tIF #tempInputValue < #INPUT_MIN THEN\n\t    #LinearizedValue := #OUTPUT_MIN;\n\t    #Error := TRUE;\n\t    #Status := #STATUS_ERROR;\n\tELSIF #tempInputValue < (#INPUT_MIN + #INPUT_RANGE1) THEN\n\t    #LinearizedValue := (#tempSlope1 * #tempInputValue) + #tempIntercept1;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSIF #tempInputValue < (#INPUT_MIN + #INPUT_RANGE1 + #INPUT_RANGE2) THEN\n\t    #LinearizedValue := (#tempSlope2 * #tempInputValue) + #tempIntercept2;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSIF #tempInputValue <= #INPUT_MAX THEN\n\t    #LinearizedValue := (#tempSlope3 * #tempInputValue) + #tempIntercept3;\n\t    #Error := FALSE;\n\t    #Status := 16#0000;\n\tELSE\n\t    #LinearizedValue := #OUTPUT_MAX;\n\t    #Error := TRUE;\n\t    #Status := #STATUS_ERROR;\n\tEND_IF;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputValue : Real;    //浮点数输入，原始测量值\n    END_VAR\n\n    VAR_OUTPUT\n        LinearizedValue : Real;    //转换后的线性化值\n        Error : Bool;    //错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错\n        Status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "自动化生产线控制", "description": "一个简单的自动化生产线由三个工作站组成：工作站A、工作站B和工作站C。产品需要经过这三个站的依次加工后才算全部完成。生产线有一个电机，负责将产品从一个工作站移动到下一个工作站，生成线的顺序是从工作站A到工作站B，再到工作站C。每个工作站都有一个传感器（用于检测产品是否到达）以及一个按钮（用于触发本站加工完成信号）。\n控制要求：\n1. 模式切换：转换开关（Mode）用于切换生产线的手动和自动模式。\n2. 手动模式：在手动模式下，电机正转按钮（ForwardButton）控制电机正转，电机反转按钮（ReverseButton）控制电机反转，正反转操作需要互锁，不能同时进行。\n3. 自动模式：\n   - 产品到达工作站A，SensorA检测到产品，操作员通过ButtonA触发加工完成信号后，电机启动正转，将产品移动到工作站B。\n   - 产品到达工作站B，SensorB检测到产品，电机停止，操作员通过ButtonB触发加工完成信号后，电机启动正转，将产品移动到工作站C。\n   - 产品到达工作站C，SensorC检测到产品，电机停止，操作员通过ButtonC触发加工完成信号后，加工完成指示灯（CompletionLight）亮起，指示产品加工完成。当产品被取走，也就是SensorC检测不到产品了，加工完成指示灯（CompletionLight）熄灭。", "type": "FUNCTION_BLOCK", "name": "FB_ProductionLineControl", "input": [{"name": "Mode", "type": "Bool", "description": "用于切换生产线的手动和自动模式，0=手动模式，1=自动模式"}, {"name": "ForwardButton", "type": "Bool", "description": "正转按钮"}, {"name": "ReverseButton", "type": "Bool", "description": "反转按钮"}, {"name": "SensorA", "type": "Bool", "description": "传感器A"}, {"name": "SensorB", "type": "Bool", "description": "传感器B"}, {"name": "SensorC", "type": "Bool", "description": "传感器C"}, {"name": "ButtonA", "type": "Bool", "description": "按钮A"}, {"name": "ButtonB", "type": "Bool", "description": "按钮B"}, {"name": "ButtonC", "type": "Bool", "description": "按钮C"}], "output": [{"name": "MotorForward", "type": "Bool", "description": "电机正转输出"}, {"name": "MotorReverse", "type": "Bool", "description": "电机反转输出"}, {"name": "CompletionLight", "type": "Bool", "description": "产品加工完成指示灯"}], "in/out": [], "return_value": [], "ID": 5, "is_sample": false, "cot": "1. 定义输入输出变量\n2. 根据模式切换开关（Mode）判断当前是手动模式还是自动模式\n3. 如果是手动模式，根据正转按钮（ForwardButton）和反转按钮（ReverseButton）的状态控制电机的正反转\n4. 如果是自动模式，根据传感器和按钮的状态控制电机的正转和加工完成指示灯的亮灭\n\n", "answer": "FUNCTION_BLOCK \"FB_ProductionLineControl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      Mode : Bool;   // 模式选择，手动或自动\n      ForwardButton : Bool;   // 正转按钮\n      ReverseButton : Bool;   // 反转按钮\n      SensorA : Bool;   // 传感器A\n      SensorB : Bool;   // 传感器B\n      SensorC : Bool;   // 传感器C\n      ButtonA : Bool;   // 按钮A\n      ButtonB : Bool;   // 按钮B\n      ButtonC : Bool;   // 按钮C\n   END_VAR\n\n   VAR_OUTPUT \n      MotorForward : Bool;   // 电机正转输出\n      MotorReverse : Bool;   // 电机反转输出\n      CompletionLight : Bool;   // 产品加工完成指示灯\n   END_VAR\n\n   VAR \n      statSensorA : Bool;\n      statSensorB : Bool;\n      statSensorC : Bool;\n      statButtonA : Bool;\n      statButtonB : Bool;\n      statButtonC : Bool;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         SensorA : Bool;\n         SensorB : Bool;\n         SensorC : Bool;\n         ButtonA : Bool;\n         ButtonB : Bool;\n         ButtonC : Bool;\n      END_STRUCT;\n   END_VAR\n\n   VAR CONSTANT \n      MANUAL_MODE : Bool := FALSE;\n      AUTO_MODE : Bool := TRUE;\n      FORWARD : Bool := TRUE;\n      REVERSE : Bool := FALSE;\n      COMPLETED : Bool := TRUE;\n      INCOMPLETE : Bool := FALSE;\n   END_VAR\n\n\nBEGIN\n\t// 模式选择\n\tIF #Mode = #MANUAL_MODE THEN\n\t    // 手动模式\n\t    #MotorForward := #ForwardButton AND NOT #ReverseButton;\n\t    #MotorReverse := #ReverseButton AND NOT #ForwardButton;\n\t    \n\tELSE\n\t    // 自动模式\n\t    // 传感器状态更新\n\t    #statSensorA := #SensorA;\n\t    #statSensorB := #SensorB;\n\t    #statSensorC := #SensorC;\n\t    \n\t    // 按钮状态更新\n\t    #statButtonA := #ButtonA;\n\t    #statButtonB := #ButtonB;\n\t    #statButtonC := #ButtonC;\n\t    \n\t    // 电机控制逻辑\n\t    IF #statSensorA AND #statButtonA THEN\n\t        #MotorForward := #FORWARD;\n\t        \n\t    ELSIF #statSensorB AND #statButtonB THEN\n\t        #MotorForward := #FORWARD;\n\t        \n\t    ELSE\n\t        #MotorForward := #INCOMPLETE;\n\t        \n\t    END_IF;\n\t    \n\t    // 加工完成指示灯逻辑\n\t    IF #statSensorC AND #statButtonC THEN\n\t        #CompletionLight := #COMPLETED;\n\t        \n\t    ELSE\n\t        #CompletionLight := #INCOMPLETE;\n\t        \n\t    END_IF;\n\t    \n\tEND_IF;\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        Mode : Bool;    //用于切换生产线的手动和自动模式，0=手动模式，1=自动模式\n        ForwardButton : Bool;    //正转按钮\n        ReverseButton : Bool;    //反转按钮\n        SensorA : Bool;    //传感器A\n        SensorB : Bool;    //传感器B\n        SensorC : Bool;    //传感器C\n        ButtonA : Bool;    //按钮A\n        ButtonB : Bool;    //按钮B\n        ButtonC : Bool;    //按钮C\n    END_VAR\n\n    VAR_OUTPUT\n        MotorForward : Bool;    //电机正转输出\n        MotorReverse : Bool;    //电机反转输出\n        CompletionLight : Bool;    //产品加工完成指示灯\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "配方管理系统", "description": "某工厂的生产线需要根据不同的配方生产多种产品。生产线的控制中心需要一个配方管理系统，允许操作员添加、删除、修改和查询配方数据。\n控制要求：\n配方数据应包括配方编号、原料类型、原料比例和生产温度。\n系统应允许输入新的配方数据，并将其存储在配方数据库中。\n系统应允许通过配方编号删除或修改现有的配方数据。\n系统应允许通过配方编号查询配方详情，并输出该配方。\n说明：\n1. 配方以结构体Struct数据类型构建，结构体内包括配方编号recipeID、原料类型ingredientType、原料比例ingredientRatio和生产温度productionTemperature。配方数据库最多可以存放10条配方，以数组Array[1..10] of Struct构建，配方编号不能重复，配方编号=0表示该位置空闲。\n2. 当触发查询配方请求信号queryRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8001。如果存在该编号，则把该条配方输出到配方查询结果recipeQueryResult。\n3. 当触发添加配方请求信号addRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果存在重号，则输出错误状态error=true和错误代码status=16#8002。如果配方数据库recipe中没有空余位置，则输出错误状态error=true和错误代码status=16#8003。如果不存在这些错误，则把输入配方recipeIn存入配方数据库recipe，优先存入数组编号小的空闲位置。\n4. 当触发删除配方请求信号deleteRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8004。如果存在该编号，则删除该配方，即把配方数据库recipe中的该条配方编号recipeID置为0。\n5. 当触发修改配方请求信号modifyRecipe时，首先根据输入配方recipeIn中的配方编号recipeID比对配方数据库recipe中的所有配方，如果不存在该编号，则输出错误状态error=true和错误代码status=16#8005。如果存在该编号，则把该条配方替换为输入配方recipeIn。", "type": "FUNCTION_BLOCK", "name": "FB_RecipeManager", "input": [{"name": "addRecipe", "type": "Bool", "description": "添加配方请求信号"}, {"name": "deleteRecipe", "type": "Bool", "description": "删除配方请求信号"}, {"name": "modifyRecipe", "type": "Bool", "description": "修改配方请求信号"}, {"name": "queryRecipe", "type": "Bool", "description": "查询配方请求信号"}, {"name": "recipeIn", "type": "Struct", "description": "输入配方", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}], "output": [{"name": "recipeAdded", "type": "Bool", "description": "配方添加成功指示"}, {"name": "recipeDeleted", "type": "Bool", "description": "配方删除成功指示"}, {"name": "recipeModified", "type": "Bool", "description": "配方修改成功指示"}, {"name": "recipeQueryResult", "type": "Struct", "description": "配方查询结果输出", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}, {"name": "error", "type": "Bool", "description": "错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "recipe", "type": "Array[1..10] of Struct", "description": "配方数据库", "fields": [{"name": "recipeID", "type": "Int", "description": "配方编号"}, {"name": "ingredientType", "type": "Int", "description": "原料类型"}, {"name": "ingredientRatio", "type": "Real", "description": "原料比例"}, {"name": "productionTemperature", "type": "Real", "description": "生产温度"}]}], "return_value": [], "ID": 6, "is_sample": false, "cot": "1. 定义配方结构体和配方数据库\n2. 查询配方功能\n3. 添加配方功能\n4. 删除配方功能\n5. 修改配方功能\n\n", "answer": "FUNCTION_BLOCK \"FB_RecipeManager\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      addRecipe : Bool;\n      deleteRecipe : Bool;\n      modifyRecipe : Bool;\n      queryRecipe : Bool;\n      recipeIn : Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n   END_VAR\n\n   VAR_OUTPUT \n      recipeAdded : Bool;\n      recipeDeleted : Bool;\n      recipeModified : Bool;\n      recipeQueryResult : Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      recipe : Array[1..10] of Struct\n         recipeID : DInt;\n         ingredientType : String;\n         ingredientRatio : Real;\n         productionTemperature : Real;\n      END_STRUCT;\n   END_VAR\n\n   VAR \n      statRecipeIndex : Int := 0;\n      statRecipeFound : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempRecipeIndex : Int;\n      tempRecipeID : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_DUPLICATE_ID : Word := 16#8002;\n      ERR_NO_EMPTY_SLOT : Word := 16#8003;\n      ERR_ID_NOT_FOUND : Word := 16#8004;\n      ERR_ID_NOT_FOUND_MODIFY : Word := 16#8005;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            FB_RecipeManager\n\t  // Comment/Function: This function block manages recipes for a production line.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  // Initialize outputs\n\t  #recipeAdded := false;\n\t  #recipeDeleted := false;\n\t  #recipeModified := false;\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // Initialize temp variables\n\t  #tempRecipeIndex := 0;\n\t  #tempRecipeID := 0;\n\tEND_REGION\n\t\n\tREGION Recipe management logic\n\t  // Check for query request\n\t  IF #queryRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, copy to output\n\t              #recipeQueryResult := #recipe[#tempRecipeIndex];\n\t              #statRecipeFound := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF NOT #statRecipeFound THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND;\n\t      END_IF;\n\t      \n\t  // Check for add request\n\t  ELSIF #addRecipe THEN\n\t      // Search for empty slot in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = 0 THEN\n\t              // Empty slot found, add recipe\n\t              #recipe[#tempRecipeIndex] := #recipeIn;\n\t              #recipeAdded := true;\n\t              EXIT;\n\t          ELSIF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Duplicate ID found, set error\n\t              #error := true;\n\t              #status := #ERR_DUPLICATE_ID;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If no empty slot found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_NO_EMPTY_SLOT;\n\t      END_IF;\n\t      \n\t  // Check for delete request\n\t  ELSIF #deleteRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, delete\n\t              #recipe[#tempRecipeIndex].recipeID := 0;\n\t              #recipeDeleted := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND;\n\t      END_IF;\n\t      \n\t  // Check for modify request\n\t  ELSIF #modifyRecipe THEN\n\t      // Search for recipe in database\n\t      FOR #tempRecipeIndex := 1 TO 10 DO\n\t          IF #recipe[#tempRecipeIndex].recipeID = #recipeIn.recipeID THEN\n\t              // Recipe found, modify\n\t              #recipe[#tempRecipeIndex] := #recipeIn;\n\t              #recipeModified := true;\n\t              EXIT;\n\t          END_IF;\n\t      END_FOR;\n\t      \n\t      // If recipe not found, set error\n\t      IF #tempRecipeIndex = 11 THEN\n\t          #error := true;\n\t          #status := #ERR_ID_NOT_FOUND_MODIFY;\n\t      END_IF;\n\t      \n\t  END_IF;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        addRecipe : Bool;    //添加配方请求信号\n        deleteRecipe : Bool;    //删除配方请求信号\n        modifyRecipe : Bool;    //修改配方请求信号\n        queryRecipe : Bool;    //查询配方请求信号\n        recipeIn : Struct    //输入配方\n            recipeID : Int;    //配方编号\n            ingredientType : Int;    //原料类型\n            ingredientRatio : Real;    //原料比例\n            productionTemperature : Real;    //生产温度\n        END_STRUCT;\n    END_VAR\n\n    VAR_OUTPUT\n        recipeAdded : Bool;    //配方添加成功指示\n        recipeDeleted : Bool;    //配方删除成功指示\n        recipeModified : Bool;    //配方修改成功指示\n        recipeQueryResult : Struct    //配方查询结果输出\n            recipeID : Int;    //配方编号\n            ingredientType : Int;    //原料类型\n            ingredientRatio : Real;    //原料比例\n            productionTemperature : Real;    //生产温度\n        END_STRUCT;\n        error : Bool;    //错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        recipe : Array[1..10] of Struct    //配方数据库\n            recipeID : Int;    //配方编号\n            ingredientType : Int;    //原料类型\n            ingredientRatio : Real;    //原料比例\n            productionTemperature : Real;    //生产温度\n        END_STRUCT;\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "数字位分离显示", "description": "在一些自动化系统中，可能需要将一个整数的各个位分离出来，以便于显示或进一步处理。例如，在一些计数器或生产计数应用中，需要将当前的计数值分离成个位、十位、百位和千位。\n控制要求：\n系统需要接收一个最多四位整数作为输入。\n根据输入的整数，计算并输出其个位、十位、百位和千位数值。\n如果输入的整数少于四位，则在缺失的高位上显示0。\n输出结果应该是四个独立的整数，分别代表个位、十位、百位和千位。\n说明：\n1. 要求输入的整数InputNumber大于等于0且小于10000，否则输出错误状态error=true和错误代码status=16#8001。\n2. 在计算出个、十、百、千这四个数位的数值后，对这四个数位值中非0的值进行比较并输出最小值到Min；如果InputNumber=0，则输出Min=0。", "type": "FUNCTION_BLOCK", "name": "FB_SplitNumber", "input": [{"name": "InputNumber", "type": "Int", "description": "四位整数输入"}], "output": [{"name": "Thousands", "type": "Byte", "description": "千位数值输出"}, {"name": "Hundreds", "type": "Byte", "description": "百位数值输出"}, {"name": "Tens", "type": "Byte", "description": "十位数值输出"}, {"name": "Ones", "type": "Byte", "description": "个位数值输出"}, {"name": "Min", "type": "Byte", "description": "四个数位中的非0最小值"}, {"name": "error", "type": "Bool", "description": "错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [], "return_value": [], "ID": 7, "is_sample": false, "cot": "1. 检查输入的整数是否在0到9999之间，如果不在这个范围内，设置错误状态为true，状态代码为16#8001，然后退出。\n2. 使用除法和取余运算将输入的整数分离成个位、十位、百位和千位。\n3. 将分离出来的四个数位值中非0的值进行比较，找出最小值。\n4. 将分离出来的四个数位值和最小值输出。\n5. 注意：不需要使用函数将Int类型转换为Byte类型，scl可自动完成该功能。\n6. 注意：不得使用条件赋值语句，scl不支持该结构。\n7. 注意：不得使用与函数块同名的变量，如FB_SplitNumber。\n8. 注意：不得使用任何的数据类型转换函数，不允许使用BYTE_TO_BYTE函数，部分精度的损失可以接受。\n", "answer": "FUNCTION_BLOCK \"FB_SplitNumber\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      InputNumber : Int;\n   END_VAR\n\n   VAR_OUTPUT \n      Thousands : Byte;\n      Hundreds : Byte;\n      Tens : Byte;\n      Ones : Byte;\n      Min : Byte;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempInputNumber : Int;\n      tempThousands : Int;\n      tempHundreds : Int;\n      tempTens : Int;\n      tempOnes : Int;\n      tempMin : Byte;\n   END_VAR\n\n   VAR CONSTANT \n      MAX_INPUT_NUMBER : Int := 9999;\n      MIN_INPUT_NUMBER : Int := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_INPUT_NUMBER : Word := 16#8001;\n      DIVISOR_THOUSANDS : Int := 1000;\n      DIVISOR_HUNDREDS : Int := 100;\n      DIVISOR_TENS : Int := 10;\n   END_VAR\n\n\nBEGIN\n\tREGION Initialization\n\t  #tempInputNumber := #InputNumber;\n\t  #error := FALSE;\n\t  #status := #STATUS_NO_ERROR;\n\tEND_REGION\n\t\n\tREGION Validation of input\n\t  IF (#tempInputNumber < #MIN_INPUT_NUMBER) OR (#tempInputNumber > #MAX_INPUT_NUMBER) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_INPUT_NUMBER;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Calculation of digits\n\t  #tempThousands := #tempInputNumber / #DIVISOR_THOUSANDS;\n\t  #tempHundreds := (#tempInputNumber MOD #DIVISOR_THOUSANDS) / #DIVISOR_HUNDREDS;\n\t  #tempTens := (#tempInputNumber MOD #DIVISOR_HUNDREDS) / #DIVISOR_TENS;\n\t  #tempOnes := #tempInputNumber MOD #DIVISOR_TENS;\n\tEND_REGION\n\t\n\tREGION Output results\n\t  #Thousands := #tempThousands;\n\t  #Hundreds := #tempHundreds;\n\t  #Tens := #tempTens;\n\t  #Ones := #tempOnes;\n\tEND_REGION\n\t\n\tREGION Calculation of minimum digit\n\t  #tempMin := #Ones;\n\t  \n\t  IF (#tempTens <> 0) AND (#tempTens < #tempMin) THEN\n\t    #tempMin := #tempTens;\n\t  END_IF;\n\t  \n\t  IF (#tempHundreds <> 0) AND (#tempHundreds < #tempMin) THEN\n\t    #tempMin := #tempHundreds;\n\t  END_IF;\n\t  \n\t  IF (#tempThousands <> 0) AND (#tempThousands < #tempMin) THEN\n\t    #tempMin := #tempThousands;\n\t  END_IF;\n\t  \n\t  #Min := #tempMin;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputNumber : Int;    //四位整数输入\n    END_VAR\n\n    VAR_OUTPUT\n        Thousands : Byte;    //千位数值输出\n        Hundreds : Byte;    //百位数值输出\n        Tens : Byte;    //十位数值输出\n        Ones : Byte;    //个位数值输出\n        Min : Byte;    //四个数位中的非0最小值\n        error : Bool;    //错误状态指示 FALSE: 没有发生错误 TRUE: 执行出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "16位二进制数分解为四个4位二进制数", "description": "在一些数据处理和通信应用中，需要将一个16位的二进制数分解成四个独立的4位二进制数。例如，在数据编码、解码或与外部系统的数据交换时，可能需要这种分解操作。\n控制要求：\n系统需要接收一个16位的二进制数InputWord作为输入。\n将输入的16位二进制数分解成四个4位的二进制数，分别对应输入数的最低位到最高位。\n输出这四个4位二进制数到独立的变量Byte0~Byte3中。\n同时对这4个变量Byte0~Byte3中非0的变量求取平均值，并输出到average。\n例如，InputWord=16#1203，则Byte0=3，Byte1=0，Byte2=2，Byte3=1，那么平均值average=(1+2+3)/3", "type": "FUNCTION_BLOCK", "name": "FB_SplitWordIntoBytes", "input": [{"name": "InputWord", "type": "Word", "description": "16位二进制数输入"}], "output": [{"name": "Byte0", "type": "Byte", "description": "最低的4位二进制数输出"}, {"name": "Byte1", "type": "Byte", "description": "次低的4位二进制数输出"}, {"name": "Byte2", "type": "Byte", "description": "次高的4位二进制数输出"}, {"name": "Byte3", "type": "Byte", "description": "最高的4位二进制数输出"}, {"name": "average", "type": "Real", "description": "四个字节中非零字节的平均值"}], "in/out": [], "return_value": [], "ID": 8, "is_sample": false, "cot": "1. 将输入的16位二进制数分解成四个4位的二进制数，分别对应输入数的最低位到最高位。\n2. 输出这四个4位二进制数到独立的变量Byte0~Byte3中。\n3. 对这4个变量Byte0~Byte3中非0的变量求取平均值，并输出到average。\n4. 注意：以下示例为SHR函数的用法，你必须严格按照该用法调用函数，其功能是取变量InputWord的次低4位赋值给变量Byte1：\n```scl\nByte1 := SHR(IN := #InputWord, N := 4) AND 16#0F; // 次低4位\n```", "answer": "FUNCTION_BLOCK \"FB_SplitWordIntoBytes\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT\n      InputWord : Word;\n   END_VAR\n\n   VAR_OUTPUT\n      Byte0 : Byte;\n      Byte1 : Byte;\n      Byte2 : Byte;\n      Byte3 : Byte;\n      average : Real;\n   END_VAR\n\n   VAR_TEMP\n      tempSum : Real := 0.0;\n      tempCount : Int := 0;\n   END_VAR\n\n   VAR CONSTANT\n      BYTE_SIZE : Int := 4;\n      WORD_SIZE : Int := 16;\n      DIVISOR : Real := 16.0;\n   END_VAR\n\n\nBEGIN\n   #Byte0 := #InputWord AND 16#0F; // 最低4位\n   #Byte1 := SHR(IN := #InputWord, N := #BYTE_SIZE) AND 16#0F; // 次低4位\n   #Byte2 := SHR(IN := #InputWord, N := #BYTE_SIZE * 2) AND 16#0F; // 次高4位\n   #Byte3 := SHR(IN := #InputWord, N := #BYTE_SIZE * 3) AND 16#0F; // 最高4位\n\n   // 计算非零字节的平均值\n   IF #Byte0 <> 0 THEN\n      #tempSum += #Byte0;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte1 <> 0 THEN\n      #tempSum += #Byte1;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte2 <> 0 THEN\n      #tempSum += #Byte2;\n      #tempCount += 1;\n   END_IF;\n   IF #Byte3 <> 0 THEN\n      #tempSum += #Byte3;\n      #tempCount += 1;\n   END_IF;\n\n   IF #tempCount > 0 THEN\n      #average := #tempSum / #tempCount;\n   ELSE\n      #average := 0.0;\n   END_IF;\n\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        InputWord : Word;    //16位二进制数输入\n    END_VAR\n\n    VAR_OUTPUT\n        Byte0 : Byte;    //最低的4位二进制数输出\n        Byte1 : Byte;    //次低的4位二进制数输出\n        Byte2 : Byte;    //次高的4位二进制数输出\n        Byte3 : Byte;    //最高的4位二进制数输出\n        average : Real;    //四个字节中非零字节的平均值\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "自动化仓库货架位置管理系统", "description": "一个自动化仓库需要一个系统来管理工件的存放位置，确保工件能够高效地被存取。仓库里有一个货架，共有9层，每层编号从1到9，每层仅能存放一件工件。\n控制要求：\n1. 系统需要维护货架的存储状态，记录每层是否存放工件。\n2. 当工件入库时：\n   - 查询货架的存储状态。\n   - 如果有空闲位置，优先存放编号大的位置。\n   - 如果所有位置都被占用，则输出错误状态error=1和错误代码status16#8001。\n3. 当工件出库时：\n   - 查询货架的存储状态。\n   - 如果货架上有工件，优先取出位置编号小的工件。\n   - 如果所有位置都为空，则输出错误状态error=1和错误代码status16#8002。\n4. 系统应能输出当前工件库存数量和货架空闲位置数量。", "type": "FUNCTION_BLOCK", "name": "FB_WarehouseManagement", "input": [{"name": "requestIn", "type": "Bool", "description": "入库请求信号"}, {"name": "requestOut", "type": "Bool", "description": "出库请求信号"}], "output": [{"name": "productNum", "type": "Int", "description": "工件库存数量"}, {"name": "libFreeNum", "type": "Int", "description": "货架空闲位置数量"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误 TRUE: 执行出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "library", "type": "Array[1..9] of Bool", "description": "货架每层的占用状态，1表示占用，0表示空闲"}], "return_value": [], "ID": 9, "is_sample": false, "cot": "1. 初始化变量。\n2. 检查入库和出库请求信号。\n3. 如果有入库请求，检查货架状态，找到最大的空闲位置，如果没有空闲位置，设置错误状态和错误代码。\n4. 如果有出库请求，检查货架状态，找到最小的占用位置，如果没有占用位置，设置错误状态和错误代码。\n5. 计算并输出当前工件库存数量和货架空闲位置数量。\n6. 注意：FOR循环若要使循环从大到小开始，你需要使用如下示例格式，不得使用DOWNTO。正确示例如下：\n```scl\nFOR 循环变量 := 初始值 TO 结束值 BY -1 DO\n    语句\nEND_FOR;\n```\n7. 注意：以下程序是不被允许的，scl不接受：\n```scl\nFOR 循环变量 := 初始值 DOWNTO 结束值 DO\n    语句\nEND_FOR;\n```\n\n", "answer": "﻿FUNCTION_BLOCK \"FB_WarehouseManagement\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      requestIn : Bool;   // 入库请求\n      requestOut : Bool;   // 出库请求\n   END_VAR\n\n   VAR_OUTPUT \n      productNum : Int;   // 工件库存数量\n      libFreeNum : Int;   // 货架空闲位置数量\n      error : Bool;   // 错误状态\n      status : Word;   // 状态代码\n   END_VAR\n\n   VAR_IN_OUT \n      library : Array[1..9] of Bool;   // 货架每层的占用状态\n   END_VAR\n\n   VAR \n      statProductCount : Int;   // 工件数量统计\n      statFreeCount : Int;   // 空闲位置数量统计\n   END_VAR\n\n   VAR_TEMP \n      tempIndex : Int;\n   END_VAR\n\n   VAR CONSTANT \n      MAX_LEVEL : Int := 9;\n      STATUS_OK : Word := 16#0000;\n      STATUS_NO_SPACE : Word := 16#8001;\n      STATUS_NO_PRODUCT : Word := 16#8002;\n   END_VAR\n\n\nBEGIN\n\t// 初始化状态\n\t#statProductCount := 0;\n\t#statFreeCount := 0;\n\t\n\t// 计算当前工件数量和空闲位置数量\n\tFOR #tempIndex := 1 TO #MAX_LEVEL DO\n\t    IF #library[#tempIndex] THEN\n\t        #statProductCount += 1;\n\t    ELSE\n\t        #statFreeCount += 1;\n\t    END_IF;\n\tEND_FOR;\n\t\n\t// 入库请求处理\n\tIF #requestIn THEN\n\t    \n\t    // 检查是否有空闲位置\n\t    IF #statFreeCount > 0 THEN\n\t        \n\t        // 从编号大的位置开始查找空闲位置\n\t        FOR #tempIndex := #MAX_LEVEL TO 1 BY -1 DO\n\t            IF NOT #library[#tempIndex] THEN\n\t                #library[#tempIndex] := TRUE;\n\t                #statProductCount += 1;\n\t                #statFreeCount -= 1;\n\t                EXIT;\n\t            END_IF;\n\t        END_FOR;\n\t        \n\t    ELSE\n\t        // 所有位置都被占用\n\t        #error := TRUE;\n\t        #status := #STATUS_NO_SPACE;\n\t        RETURN;\n\t        \n\t    END_IF;\n\t    \n\tELSIF #requestOut THEN\n\t    \n\t    // 检查是否有工件\n\t    IF #statProductCount > 0 THEN\n\t        \n\t        // 从编号小的位置开始查找工件\n\t        FOR #tempIndex := 1 TO #MAX_LEVEL DO\n\t            IF #library[#tempIndex] THEN\n\t                #library[#tempIndex] := FALSE;\n\t                #statProductCount -= 1;\n\t                #statFreeCount += 1;\n\t                EXIT;\n\t            END_IF;\n\t        END_FOR;\n\t        \n\t    ELSE\n\t        // 所有位置都为空\n\t        #error := TRUE;\n\t        #status := #STATUS_NO_PRODUCT;\n\t        RETURN;\n\t        \n\t    END_IF;\n\t    \n\tEND_IF;\n\t\n\t// 输出当前状态\n\t#productNum := #statProductCount;\n\t#libFreeNum := #statFreeCount;\n\t#error := FALSE;\n\t#status := #STATUS_OK;\n\t\nEND_FUNCTION_BLOCK\n", "var": "\n    VAR_INPUT\n        requestIn : Bool;    //入库请求信号\n        requestOut : Bool;    //出库请求信号\n    END_VAR\n\n    VAR_OUTPUT\n        productNum : Int;    //工件库存数量\n        libFreeNum : Int;    //货架空闲位置数量\n        error : Bool;    //FALSE: 没有发生错误 TRUE: 执行出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        library : Array[1..9] of Bool;    //货架每层的占用状态，1表示占用，0表示空闲\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "双字边沿检测", "description": "编写一个函数块FB，该函数块每周期检查一个双字（DWord）输入值中的每一位的上升沿和下降沿。函数块应能够检测并报告输入值中的变化、上升边沿和下降边沿。\n\n示例：\n假设输入值从2#101变为2#11011，则上升沿数量为3，上升边沿的位流为2#11010，下降沿数量为1，下降边沿的位流为2#100。", "type": "FUNCTION_BLOCK", "name": "GetBitStates", "input": [{"name": "value", "type": "DWord", "description": "待检查变化和边沿触发的输入值"}], "output": [{"name": "hasChanged", "type": "Bool", "description": "为True时表示输入值已改变"}, {"name": "hasRisingEdges", "type": "Bool", "description": "为True时表示输入值出现上升边沿"}, {"name": "risingBits", "type": "DWord", "description": "上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）"}, {"name": "noOfRisingBits", "type": "USInt", "description": "输入值中的上升边沿数量"}, {"name": "hasFallingEdges", "type": "Bool", "description": "为True时表示输入值出现下降边沿"}, {"name": "fallingBits", "type": "DWord", "description": "下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）"}, {"name": "noOfFallingBits", "type": "USInt", "description": "输入值中的下降边沿数量"}], "answer": "﻿FUNCTION_BLOCK \"GetBitStates\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      value : DWord;\n   END_VAR\n\n   VAR_OUTPUT \n      hasChanged  : Bool;\n      hasRisingEdges : Bool;\n      risingBits  : DWord;\n      noOfRisingBits  : USInt;\n      hasFallingEdges  : Bool;\n      fallingBits  : DWord;\n      noOfFallingBits  : USInt;\n   END_VAR\n\n   VAR \n      statPreviousValue  : DWord;\n   END_VAR\n\n   VAR_TEMP \n      tempRisingResult : DWord;\n      tempNoRisingBits : DWord;\n      tempFallingResult : DWord;\n      tempNoFallingBits : DWord;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_EDGES : DWord;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //============================================================================\n\t  // Title:            GetBitStates\n\t  // Comment/Function: Check DWord for edges, falling as well as rising.  \n\t  //                   Returns the number of edges, DWords with edge bits and a bool if edge(s) exists.\n\t  //                   https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t\n\t  //=============================================================================\n\tEND_REGION BLOCK INFO HEADER\n\t\n\tREGION PROGRAM LOGIC\n\t  // Get edges from input DWord and DWord from previous cycle\n\t  #tempRisingResult := #value AND NOT #statPreviousValue;\n\t  #tempFallingResult := NOT #value AND #statPreviousValue;\n\t  \n\t  // Store value for next cycle\n\t  #statPreviousValue := #value;\n\t  \n\t  // Copy edge result into work variable for counting the number of rising edges\n\t  #tempNoRisingBits := #tempRisingResult;\n\t  // Count number of rising edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 1) AND 16#55555555));\n\t  #tempNoRisingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 2) AND 16#33333333));\n\t  #tempNoRisingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoRisingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoRisingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\t  \n\t  // Copy edges result into work variable for counting the number of falling edges\n\t  #tempNoFallingBits := #tempFallingResult;\n\t  // Count number of falling edges, algorythm descriped from: https://graphics.stanford.edu/~seander/bithacks.html#CountBitsSetParallel\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) - DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 1) AND 16#55555555));\n\t  #tempNoFallingBits := UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits & 16#33333333) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 2) AND 16#33333333));\n\t  #tempNoFallingBits := SHR(IN := UDINT_TO_DWORD(DWORD_TO_UDINT(UDINT_TO_DWORD(DWORD_TO_UDINT(#tempNoFallingBits) + DWORD_TO_UDINT(SHR(IN := #tempNoFallingBits, N := 4))) AND 16#0F0F0F0F) * DWORD_TO_UDINT(16#01010101)), N := 24);\n\tEND_REGION PROGRAM LOGIC\n\t\n\tREGION OUTPUTS\n\t  #hasChanged := (#tempRisingResult > #ZERO_EDGES) OR (#tempFallingResult > #ZERO_EDGES);\n\t  #hasRisingEdges := #tempRisingResult > #ZERO_EDGES;\n\t  #risingBits := #tempRisingResult;\n\t  #noOfRisingBits := DWORD_TO_USINT(#tempNoRisingBits);\n\t  \n\t  #hasFallingEdges := #tempFallingResult > #ZERO_EDGES;\n\t  #fallingBits := #tempFallingResult;\n\t  #noOfFallingBits := DWORD_TO_USINT(#tempNoFallingBits);\n\t  \n\t  // ENO not needed, no error evaluation needed\n\t  ENO := FALSE;\n\tEND_REGION OUTPUTS\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": [], "ID": 10, "cot": "1.定义一个静态变量来存储上一周期的输入值。\n2.计算输入值与上一周期输入值的异或，得到变化的位。\n3.计算输入值与变化的位的与，得到上升边沿的位。\n4.计算上一周期的输入值与变化的位的与，得到下降边沿的位。\n5.计算上升边沿和下降边沿的位的数量。\n6.更新输出变量。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        value : DWord;    //待检查变化和边沿触发的输入值\n    END_VAR\n\n    VAR_OUTPUT\n        hasChanged : Bool;    //为True时表示输入值已改变\n        hasRisingEdges : Bool;    //为True时表示输入值出现上升边沿\n        risingBits : DWord;    //上升边沿的位流，其中每个位表示相应位置的输入值是否发生了上升沿（1表示有上升沿，0表示无上升沿）\n        noOfRisingBits : USInt;    //输入值中的上升边沿数量\n        hasFallingEdges : Bool;    //为True时表示输入值出现下降边沿\n        fallingBits : DWord;    //下降边沿的位流，其中每个位表示相应位置的输入值是否发生了下降沿（1表示有下降沿，0表示无下降沿）\n        noOfFallingBits : USInt;    //输入值中的下降边沿数量\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "数据类型为DTL的日期时间转换为字符串", "description": "编写一个函数FC，该函数能够将数据类型为DTL的日期时间值转换为字符串，并按照自定义的分隔符输出。转换后的字符串格式应为YYYY<分隔符>MM<分隔符>DD<分隔符>HH:mm:ss.nnnnnnnn，其中<分隔符>为函数参数指定的字符。这里HH代表小时（24小时制），mm代表分钟，ss代表秒，nnnnnnnn代表纳秒。注意，分隔符不应用于时分秒纳秒之间。\n\n示例：\n假设输入的DTL日期时间为2023-09-17 12:34:56.123456789，自定义分隔符为-。\n函数应返回字符串\"2023-09-17 12:34:56.123456789\"作为转换结果。", "type": "FUNCTION", "name": "DTLToString_ISO", "input": [{"name": "date", "type": "DTL", "description": "数据类型为DTL的日期"}, {"name": "separator", "type": "Char", "description": "转换后的日期中年和月之间，以及月和日之间的分隔符"}], "return_value": [{"type": "String", "description": "转换后的日期字符串"}], "answer": "﻿FUNCTION \"DTLToString_ISO\" : String\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      \"date\"  : DTL;\n      separator : Char;\n   END_VAR\n\n   VAR_TEMP \n      tempString : String;\n      tempIndex : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      CONVERT_SIZE_YEAR : USInt := 4;\n      CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND : USInt := 2;\n      CONVERT_SIZE_NANOSECOND : USInt := 9;\n      CONVERT_PRECISION : USInt := 0;\n      CONVERT_FORMAT_TO_STRING : Word := 16#0000;\n      CONVERT_START_POSITION_YEAR : UInt := 1;\n      CONVERT_START_POSITION_MONTH : UInt := 6;\n      CONVERT_START_POSITION_DAY : UInt := 9;\n      CONVERT_START_POSITION_HOUR : UInt := 12;\n      CONVERT_START_POSITION_MINUTE : UInt := 15;\n      CONVERT_START_POSITION_SECOND : UInt := 18;\n      CONVERT_START_POSITION_NANOSECOND : UInt := 21;\n      SEPARATOR_POSITION_YEAR_MONTH : UInt := 5;\n      SEPARATOR_POSITION_MONTH_DAY : UInt := 8;\n      SEPARATOR_POSITION_HOUR_MINUTE : UInt := 14;\n      SEPARATOR_POSITION_MINUTE_SECOND : UInt := 17;\n      SEPARATOR_POSITION_SECOND_NANOSECOND : UInt := 20;\n      SEPARATOR_NANOSECOND : Char := '.';\n      SEPARATOR_TIME : Char := ':';\n      SEPARATOR_DATE : Char := '-';\n      REPLACE_NANOSECOND_COUNT : DInt := 8;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            DTLtoString_ISO\n\t  // Comment/Function: This function converts a date of data type DTL into a character string of data type STRING in international format (YYYY MM DD…).\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION INITIALISATION\n\t  #tempString := '';\n\tEND_REGION\n\t\n\tREGION CONVERTER\n\t  // Set format parameters for output string\n\t  // International ISO 8601\n\t  // DTL  | Y| Y| Y| Y| -| M| M| -| D| D|  | H| H| :| M| M| :| S| S| .|NS|NS|NS|NS|NS|NS|NS|NS|NS\n\t  // -----|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--|--\n\t  // Pos  | 1| 2| 3| 4| 5| 6| 7| 8| 9|10|11|12|13|14|15|16|17|18|19|20|21|22|23|24|25|26|27|28|29\n\t  \n\t  // Convert \"Value\" into \"String\" and place at the right position\n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.YEAR,\n\t           P      := #CONVERT_START_POSITION_YEAR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_YEAR,\n\t           OUT    => #tempString);    // DTL YEAR --> String --> #tempPosYear\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MONTH,\n\t           P      := #CONVERT_START_POSITION_MONTH,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MONTH --> String --> #tempPosMonth\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.DAY,\n\t           P      := #CONVERT_START_POSITION_DAY,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL DAY --> String --> #tempPosDay\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.HOUR,\n\t           P      := #CONVERT_START_POSITION_HOUR,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL HOUR --> String --> #tempPosHour\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.MINUTE,\n\t           P      := #CONVERT_START_POSITION_MINUTE,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL MINUTE --> String --> #tempPosMinute\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.SECOND,\n\t           P      := #CONVERT_START_POSITION_SECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_MONTH_DAY_HOUR_MINUTE_SECOND,\n\t           OUT    => #tempString);     // DTL SECOND --> String --> #tempPosSecond\n\t  \n\t  VAL_STRG(FORMAT := #CONVERT_FORMAT_TO_STRING,\n\t           IN     := #date.NANOSECOND,\n\t           P      := #CONVERT_START_POSITION_NANOSECOND,\n\t           PREC   := #CONVERT_PRECISION,\n\t           SIZE   := #CONVERT_SIZE_NANOSECOND,\n\t           OUT    => #tempString);     // DTL NANOSECOND --> String --> #tempPosNanosecond\n\t  \n\t  // Place separators at the right position in the string\n\t  IF #separator = '' THEN\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #SEPARATOR_DATE;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #SEPARATOR_DATE;\n\t  ELSE\n\t    #tempString[#SEPARATOR_POSITION_YEAR_MONTH] := #separator;\n\t    #tempString[#SEPARATOR_POSITION_MONTH_DAY] := #separator;\n\t  END_IF;\n\t  #tempString[#SEPARATOR_POSITION_HOUR_MINUTE] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_MINUTE_SECOND] := #SEPARATOR_TIME;\n\t  #tempString[#SEPARATOR_POSITION_SECOND_NANOSECOND] := #SEPARATOR_NANOSECOND;\n\t  \n\t  // Correcting the string, due to the conversion of a leading \"0\" value into a \"blank\".\n\t  // Replacing of \"blank\" by \"0\"\n\t  IF (#tempString[#CONVERT_START_POSITION_MONTH] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MONTH] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_DAY] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_DAY] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_HOUR] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_HOUR] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_MINUTE] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_MINUTE] := '0';\n\t  END_IF;\n\t  \n\t  IF (#tempString[#CONVERT_START_POSITION_SECOND] = ' ') THEN\n\t    #tempString[#CONVERT_START_POSITION_SECOND] := '0';\n\t  END_IF;\n\t  \n\t  FOR #tempIndex := 0 TO #REPLACE_NANOSECOND_COUNT DO\n\t    IF (#tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] = ' ') THEN\n\t      #tempString[UINT_TO_SINT(#CONVERT_START_POSITION_NANOSECOND) + #tempIndex] := '0';\n\t    ELSE\n\t      EXIT;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION OUTPUTS\n\t  #DTLToString_ISO := #tempString;\n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "output": [], "in/out": [], "ID": 11, "cot": "1. 定义函数DTLToString_ISO，输入参数为DTL类型的日期和字符类型的分隔符。\n2. 使用DTL_TO_DATE、DTL_TO_TOD和DTL_TO_TIME函数将DTL日期时间分解为日期、时间和纳秒部分。\n3. 使用DATE_TO_INT、TIME_TO_INT和TOD_TO_TIME函数将日期、时间和纳秒部分转换为整数。\n4. 使用INT_TO_STRING函数将整数转换为字符串。\n5. 使用CONCAT函数将字符串和分隔符连接起来。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        date : DTL;    //数据类型为DTL的日期\n        separator : Char;    //转换后的日期中年和月之间，以及月和日之间的分隔符\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "从字符数组中截取字符串", "description": "编写一个函数FC，该函数能够根据给定的起始字符串和结束字符串，从字符数组中截取符合要求的子字符串。\n\n1. 函数应遍历searchIn，查找textBefore首次出现的位置，然后查找随后出现的textAfter的位置。\n2. 如果找到了textBefore和textAfter，函数应截取这两个边界之间的字符串（不包括边界字符串本身），并返回这个子字符串。\n3. 如果textBefore或textAfter在searchIn中不存在，函数应返回特定的状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：输入参数searchIn不是字符数组或字节数组\n\n返回值表示查找的结果：\n- 16#0000：查找成功，头部字符和尾部字符均已找到\n- 16#9001：查找不成功，只找到了起始边界，未找到结束边界\n- 16#9002：查找不成功，起始边界未找到。\n\n示例：\n假设searchIn为\"This is a [sample] string with [multiple] boundaries.\"，textBefore为\"[\"，textAfter为\"]\"。函数应返回\"sample\"作为截取到的子字符串。", "type": "FUNCTION", "name": "ExtractStringFromCharArray", "input": [{"name": "textBefore", "type": "String", "description": "要截取的字符串的起始边界"}, {"name": "textAfter", "type": "String", "description": "要截取的字符串的结束边界"}], "output": [{"name": "extractedString", "type": "String", "description": "截取的字符串"}, {"name": "status", "type": "Word", "description": "状态代码，具体见说明"}], "in/out": [{"name": "searchIn", "type": "Variant", "description": "要在其中进行搜索的字符或字节数组"}], "return_value": [{"type": "Word", "description": "状态代码，具体见说明"}], "answer": "﻿FUNCTION \"ExtractStringFromCharArray\" : Word\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      textBefore : String;\n      textAfter : String;\n   END_VAR\n\n   VAR_OUTPUT \n      extractedString : String;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      searchIn : Variant;\n   END_VAR\n\n   VAR_TEMP \n      tempNumElements : UDInt;\n      tempPosInArray : DInt;\n      tempLenTextBefore : Int;\n      tempPosTextBefore : DInt;\n      tempLenTextAfter : Int;\n      tempPosTextAfter : Int;\n      tempString : String;\n   END_VAR\n\n   VAR CONSTANT \n      LEN_STRING : UInt := 254;\n      STATUS_TEXT_FOUND : Word := 16#0000;\n      WARNING_ONLY_START : Word := 16#9001;\n      WARNING_NOTHING_FOUND : Word := 16#9002;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            ExtractStringFromCharArray\n\t  // Function:         The function extracts a String specified by a text before and after\n\t  //                   from an array of characters.\n\t \n\t  //===============================================================================\n\tEND_REGION\n\t\n\tREGION Initialization\n\t  #tempPosTextBefore := 0;\n\t  #tempPosTextAfter := 0;\n\t  #tempPosInArray := 0;\n\t  #tempLenTextBefore := LEN(#textBefore);\n\t  #tempLenTextAfter := LEN(#textAfter);\n\t  #extractedString := '';\n\t  #status := #STATUS_NO_ERROR;\n\t  #ExtractStringFromCharArray := #WARNING_NOTHING_FOUND;\n\t  \n\t  REGION Validation of inputs\n\t    // check whether the input is an ARRAY and TYPE of elements is CHAR or BYTE\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF TRUE\n\t      AND IS_ARRAY(#searchIn)\n\t      AND ((TypeOfElements(#searchIn) = Char) OR (TypeOfElements(#searchIn) = Byte))\n\t    THEN\n\t      // Get number of elements\n\t      #tempNumElements := CountOfElements(#searchIn);\n\t    ELSE\n\t      #status := #ERR_NO_ARRAY;\n\t      RETURN;\n\t    END_IF;\n\t  END_REGION Validation of inputs\n\tEND_REGION Initialization\n\t\n\tREGION Process\n\t  REPEAT // Search for text before until something was found\n\t    // Convert Chars to String\n\t    Chars_TO_Strg(Chars  := #searchIn,\n\t                  pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                  Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                  Strg   => #tempString);\n\t    \n\t    // Search for text before\n\t    #tempPosTextBefore := FIND(IN1 := #tempString, IN2 := #textBefore);\n\t    \n\t    // Text before was found\n\t    IF #tempPosTextBefore > 0 THEN\n\t      // Set position in array to end of text before\n\t      #tempPosInArray += #tempPosTextBefore + #tempLenTextBefore - 1;\n\t      \n\t      // Create new string from end of text before\n\t      Chars_TO_Strg(Chars  := #searchIn,\n\t                    pChars := #tempPosInArray, // Subtract offset since pChars is zero based\n\t                    Cnt    := UDINT_TO_UINT(MIN(IN1 := #LEN_STRING, IN2 := #tempNumElements)),\n\t                    Strg   => #tempString);\n\t      \n\t      // Find end of string to be extracted\n\t      #tempPosTextAfter := FIND(IN1 := #tempString, IN2 := #textAfter);\n\t      \n\t      IF #tempPosTextAfter > 0 THEN // Shorten string if text after was found\n\t        #extractedString := LEFT(IN := #tempString, L := #tempPosTextAfter - 1);\n\t        #ExtractStringFromCharArray := #STATUS_TEXT_FOUND;\n\t        EXIT;\n\t        \n\t      ELSE // Output whole string if text after was not found\n\t        #extractedString := #tempString;\n\t        #ExtractStringFromCharArray := #WARNING_ONLY_START;\n\t        EXIT;\n\t      END_IF;\n\t      \n\t    ELSE\n\t      // Otherwise continue search in next string minus length of text before to ensure\n\t      // keywords are not broken up at the end of a string and thus missed\n\t      #tempPosInArray += UINT_TO_INT(#LEN_STRING) - #tempLenTextBefore;\n\t    END_IF;\n\t    \n\t    // Repeat until end of array is reached\n\t  UNTIL (#tempPosInArray > #tempNumElements) END_REPEAT;\n\tEND_REGION Process\n\t\nEND_FUNCTION\n\n", "ID": 12, "cot": "1. 首先，检查输入参数searchIn是否为字符数组或字节数组。如果不是，返回状态代码16#8200。\n2. 然后，使用内置函数FIND查找textBefore在searchIn中首次出现的位置，记为startPos。\n3. 使用FIND函数查找textAfter在searchIn中首次出现的位置，记为endPos。\n4. 如果startPos和endPos都找到了，使用内置函数MID截取startPos和endPos之间的子字符串，赋值给extractedString，并返回状态代码16#0000。\n5. 如果只找到了startPos，返回状态代码16#9001。\n6. 如果startPos都没找到，返回状态代码16#9002。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        textBefore : String;    //要截取的字符串的起始边界\n        textAfter : String;    //要截取的字符串的结束边界\n    END_VAR\n\n    VAR_OUTPUT\n        extractedString : String;    //截取的字符串\n        status : Word;    //状态代码，具体见说明\n    END_VAR\n\n    VAR_IN_OUT\n        searchIn : Variant;    //要在其中进行搜索的字符或字节数组\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "FIFO先进先出队列", "description": "编写一个函数块FB，实现一个先进先出（FIFO）循环队列的功能，其中队列的最大长度和数据类型都是可变的。循环队列应能够支持以下操作：\n\n1. 入队操作（enqueue）：在队列未满的情况下，将一个元素添加到队列的队尾。\n2. 出队操作（dequeue）：在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n3. 判断队列是否为空：检查队列中是否没有元素。\n4. 判断队列是否已满：检查队列是否已达到最大容量。\n5. 获取队列元素数量：返回队列中当前元素的数量。\n状态代码：\n16#0000：执行FB没有出错\n16#8001：队列是空的\n16#8002：队列是满的", "type": "FUNCTION_BLOCK", "name": "FIFO", "input": [{"name": "enqueue", "type": "Bool", "description": "入队操作，在队列未满的情况下，将一个元素添加到队列的队尾"}, {"name": "dequeue", "type": "Bool", "description": "出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "clear", "type": "Bool", "description": "清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。"}, {"name": "initialItem", "type": "Variant", "description": "用于初始化队列的值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}, {"name": "elementCount", "type": "DInt", "description": "队列中元素的数量"}, {"name": "isEmpty", "type": "Bool", "description": "当为TRUE时表示队列是空的"}], "in/out": [{"name": "item", "type": "Variant", "description": "用于加入队列或从队列返回的值"}, {"name": "buffer", "type": "Variant", "description": "用于作为队列的数组"}], "answer": "﻿FUNCTION_BLOCK \"FIFO\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enqueue : Bool := FALSE;\n      dequeue : Bool := FALSE;\n      reset : Bool;\n      clear : Bool;\n      initialItem : Variant;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n      elementCount : DInt := 0;\n      isEmpty : Bool := FALSE;\n   END_VAR\n\n   VAR_IN_OUT \n      item : Variant;\n      buffer : Variant;\n   END_VAR\n\n   VAR \n      statEdgesMem : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      statFirstItemIndex : Int := -1;\n      statNextEmptyItemIndex : Int := 0;\n      statElementCount : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempEdges : Struct\n         enqueue : Bool;\n         dequeue : Bool;\n         clear : Bool;\n      END_STRUCT;\n      tempInternalError : Int;\n      tempNewFirstItemIndex : Int;\n      tempNewNextEmptyItemIndex : Int;\n      tempBufferSize : UDInt;\n      tempCounter : Int;\n   END_VAR\n\n   VAR CONSTANT \n      BUFFER_IS_EMPTY : Int := -1;\n      NO_INTERNAL_ERROR : Int := 0;\n      BUFFER_INITIALIZED : Int := -1;\n      EMPTY_INITIALIZED : Int := 0;\n      INDEX_BEGINNING : Int := 0;\n      COUNT_ELEMENTS : UDInt := 1;\n      INCREMENT : Int := 1;\n      BUFFER_SIZE_CORRECTION : UDInt := 1;\n      COUNTER_LOWER_LIMIT : Int := 0;\n      ZERO_ELEMENTS : DInt := 0;\n      STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_NO_CURRENT_JOBS : Word := 16#7000;\n      ERR_BUFFER_EMPTY : Word := 16#8001;\n      ERR_BUFFER_FULL : Word := 16#8002;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_WRONG_TYPE_ITEM : Word := 16#8201;\n      ERR_WRONG_TYPE_INITIAL_ITEM : Word := 16#8202;\n      ERR_INDEX_IN_ARRAY_LIMITS_1 : Word := 16#8601;\n      ERR_INDEX_IN_ARRAY_LIMITS_2 : Word := 16#8602;\n      ERR_CLEAR_BUFFER : Word := 16#8610;\n      ERR_RETURN_FIRST_ENTRY : Word := 16#8611;\n      ERR_REPLACE_ITEM_BY_INIT_VALUE : Word := 16#8612;\n      ERR_WRITE_ENTRY : Word := 16#8613;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //===============================================================================\n\t    // Title:           FIFO\n\t    // Comment/Function: FIFO (First In First Out)\n\t    //                   Queue / ring buffer memory\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Block execution control\n\t    // collect edges\n\t    #tempEdges.enqueue := #enqueue AND NOT #statEdgesMem.enqueue;\n\t    #tempEdges.dequeue := #dequeue AND NOT #statEdgesMem.dequeue;\n\t    #tempEdges.clear := #clear AND NOT #statEdgesMem.clear;\n\t    // store values for edge detection\n\t    #statEdgesMem.enqueue := #enqueue;\n\t    #statEdgesMem.dequeue := #dequeue;\n\t    #statEdgesMem.clear := #clear;\n\t    \n\t    // This program code section is only executed if no trigger input is active\n\t    IF NOT (#enqueue OR #dequeue OR #reset OR #clear) THEN\n\t        // If an error occurred during program execution,\n\t        // the status \"No Current Job\" is used 16#7000 afterwarts when the triggers are reseted\n\t        #error := false;\n\t        #status := #STATUS_NO_CURRENT_JOBS;\n\t        \n\t        // the program processing OF the FB is terminated\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Validation of inputs\n\t    // check whether the ring #buffer is an ARRAY.\n\t    // IF so, the number OF the ARRAY elements is read out.\n\t    // IF it is NOT an ARRAY, the program execution is terminated at this point\n\t    IF IS_ARRAY(#buffer) THEN\n\t        #tempBufferSize := CountOfElements(#buffer);\n\t    ELSE\n\t        #error := true;\n\t        #status := #ERR_NO_ARRAY;\n\t        \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the data type OF the ARRAY elements matches\n\t    // the data type OF the entry (#item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOfElements(#buffer)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the initial value OF the ring #buffer\n\t    // matches the entry (tag #item). IF the data types DO NOT match,\n\t    // the program execution is terminated at this point\n\t    IF (TypeOf(#item) <> TypeOf(#initialItem)) THEN\n\t        #error := true;\n\t        #status := #ERR_WRONG_TYPE_INITIAL_ITEM;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // check whether the variable indices are within the ARRAY limits.\n\t    // IF they are NOT, the program execution is terminated at this point\n\t    IF (#statNextEmptyItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_1;\n\t        \n\t        RETURN;\n\t    ELSIF (#statFirstItemIndex >= #tempBufferSize) THEN\n\t        #error := true;\n\t        #status := #ERR_INDEX_IN_ARRAY_LIMITS_2;\n\t       \n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If resetBuffer is \"TRUE\", the buffer counters are reset\n\t    IF #reset THEN\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // If clearBuffer has rising edge, the buffer is initialized by initial values\n\t    IF #tempEdges.clear THEN\n\t        FOR #tempCounter := #COUNTER_LOWER_LIMIT TO UDINT_TO_INT(#tempBufferSize - #BUFFER_SIZE_CORRECTION) DO\n\t            \n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #tempCounter,\n\t                                                   DEST => #buffer);\n\t        END_FOR;\n\t        \n\t        // checks whether a local error has occurred.\n\t        IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t            #error := true;\n\t            #status := #ERR_CLEAR_BUFFER;\n\t           \n\t        END_IF;\n\t        \n\t        // reset counters\n\t        #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t        #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t        #statElementCount := #EMPTY_INITIALIZED;\n\t        #elementCount := #EMPTY_INITIALIZED;\n\t        #isEmpty := true;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION FIFO algorithm  \n\t    IF #tempEdges.dequeue THEN\n\t        REGION dequeue\n\t            // check whether the ring #buffer is empty\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statFirstItemIndex = #BUFFER_IS_EMPTY) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_EMPTY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // return the first entry of the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #buffer,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #statFirstItemIndex,\n\t                                                   DEST_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST => #item);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_RETURN_FIRST_ENTRY;\n\t               \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // check whether the ring #buffer contains ARRAY elements\n\t            // IF it does, the first entry is passed further on and the index is incremented BY 1\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #initialItem,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statFirstItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_REPLACE_ITEM_BY_INIT_VALUE;\n\t                \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // calculate the new index of the first entry\n\t            #tempNewFirstItemIndex := #statFirstItemIndex + #INCREMENT;\n\t            #tempNewFirstItemIndex := #tempNewFirstItemIndex MOD UDINT_TO_INT(#tempBufferSize);\n\t            \n\t            // check whether the ring buffer is empty\n\t            IF (#statNextEmptyItemIndex = #tempNewFirstItemIndex) THEN\n\t                // If the ring buffer is empty, the index is set to 0\n\t                #statFirstItemIndex := #BUFFER_INITIALIZED;\n\t                #statNextEmptyItemIndex := #EMPTY_INITIALIZED;\n\t            ELSE\n\t                // The index of the first entry is changed\n\t                #statFirstItemIndex := #tempNewFirstItemIndex;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount -= #INCREMENT;\n\t            \n\t        END_REGION dequeue\n\t        \n\t    ELSIF #tempEdges.enqueue THEN\n\t        REGION enqueue\n\t            // check whether the ring #buffer is full\n\t            // IF this is the CASE, program execution is terminated at this point\n\t            IF (#statNextEmptyItemIndex = #statFirstItemIndex) THEN\n\t                #error := true;\n\t                #status := #ERR_BUFFER_FULL;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // write the entry to the ring buffer\n\t            #tempInternalError := MOVE_BLK_VARIANT(SRC := #item,\n\t                                                   COUNT := #COUNT_ELEMENTS,\n\t                                                   SRC_INDEX := #INDEX_BEGINNING,\n\t                                                   DEST_INDEX := #statNextEmptyItemIndex,\n\t                                                   DEST => #buffer);\n\t            \n\t            // check whether a local error has occurred\n\t            IF (#tempInternalError <> #NO_INTERNAL_ERROR) THEN\n\t                #error := true;\n\t                #status := #ERR_WRITE_ENTRY;\n\t             \n\t                RETURN;\n\t            END_IF;\n\t            \n\t            // increment the index by 1 and calculates the new empty entry index\n\t            #tempNewNextEmptyItemIndex := (#statNextEmptyItemIndex + #INCREMENT) MOD UDINT_TO_INT(#tempBufferSize);\n\t            #statNextEmptyItemIndex := #tempNewNextEmptyItemIndex;\n\t            \n\t            // check which index the \"#firstItemIndex\" tag has\n\t            // IF the number = -1, the ring buffer is initialized\n\t            // AND the entry is written TO the ring #buffer\n\t            // Therefore, \"0\" must be assigned TO the tag\n\t            IF (#statFirstItemIndex = #BUFFER_INITIALIZED) THEN\n\t                #statFirstItemIndex := #INDEX_BEGINNING;\n\t            END_IF;\n\t            \n\t            // Evaluation of the number of elements in the stack\n\t            #statElementCount += #INCREMENT;\n\t        END_REGION enqueue\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t    #elementCount := #statElementCount;\n\t    #isEmpty := #statElementCount <= #ZERO_ELEMENTS;\n\t    \n\t    #error := false;\n\t    #status := #STATUS_NO_ERROR;\n\t \n\t    // no error handling by ENO needed\n\t    ENO := TRUE;\n\tEND_REGION\n\t\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": [], "ID": 13, "cot": "1. 定义函数块FIFO，定义输入、输出、输入/输出、变量、临时变量和常量。\n2. 在函数块中，首先判断是否进行复位操作，如果是，则复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n3. 判断是否进行清除操作，如果是，则复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n4. 判断是否进行入队操作，如果是，首先判断队列是否已满，如果已满，则设置错误状态为TRUE，状态代码为16#8002，如果未满，则将元素添加到队列的队尾，更新队尾指针和元素计数。\n5. 判断是否进行出队操作，如果是，首先判断队列是否为空，如果为空，则设置错误状态为TRUE，状态代码为16#8001，如果不为空，则从队列的队首移除一个元素，更新队首指针和元素计数，返回该元素的值。\n6. 判断队列是否为空，如果为空，则设置isEmpty输出为TRUE，否则设置为FALSE。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        enqueue : Bool;    //入队操作，在队列未满的情况下，将一个元素添加到队列的队尾\n        dequeue : Bool;    //出队操作，在队列不空的情况下，从队列的队首移除一个元素，并返回该元素的值。\n        reset : Bool;    //复位操作，复位头尾指针，元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n        clear : Bool;    //清除操作，复位头尾指针，队列将被清空并用初始值initialItem进行初始化。元素计数（elementCount）输出被设置为零，并且isEmpty输出被设置为TRUE。\n        initialItem : Variant;    //用于初始化队列的值\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE:没有发生错误 TRUE:执行FB时出错\n        status : Word;    //状态代码\n        elementCount : DInt;    //队列中元素的数量\n        isEmpty : Bool;    //当为TRUE时表示队列是空的\n    END_VAR\n\n    VAR_IN_OUT\n        item : Variant;    //用于加入队列或从队列返回的值\n        buffer : Variant;    //用于作为队列的数组\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "计算移动平均值", "description": "编写一个函数块FB，该函数块计算并更新一个移动算术平均值。移动算术平均值是一种在连续数据点上进行平均的方法，其中每个新的数据点都会替换掉最旧的数据点，然后重新计算平均值。\n\n1. cyclicExecution为TRUE时，每个扫描周期自动读取一次新数据value，并更新移动平均值average。\n2. 提供外部触发信号trigger，当触发上升沿时，立即读取一次新数据并更新移动平均值。\n3. 提供复位功能reset，当复位信号为TRUE时，重置移动平均值计算。如果窗口大小小于1或大于100，则输出错误状态和状态代码。\n\nstatus参数表示程序的执行状态：\n- 16#0000：执行成功\n- 16#8200：窗口长度设置错误，请设置一个介于1到100之间的值。", "type": "FUNCTION_BLOCK", "name": "FloatingAverage", "input": [{"name": "cyclicExecution", "type": "Bool", "description": "为TRUE时，周期性读取，trigger不起作用"}, {"name": "trigger", "type": "Bool", "description": "外部触发信号，每次上升沿读取value"}, {"name": "value", "type": "LReal", "description": "新读取的数据值"}, {"name": "windowSize", "type": "Int", "description": "移动平均值的窗口大小，要求范围在1到100之间"}, {"name": "reset", "type": "Bool", "description": "复位信号，当为TRUE时重置移动平均值计算"}], "output": [{"name": "average", "type": "LReal", "description": "移动平均值"}, {"name": "windowSizeReached", "type": "Bool", "description": "FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度"}, {"name": "error", "type": "Bool", "description": "FALSE:没有发生错误 TRUE:执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "answer": "﻿FUNCTION_BLOCK \"FloatingAverage\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      cyclicExecution : Bool := false;\n      trigger : Bool;\n      value : LReal;\n      windowSize : Int := 100;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      average  : LReal;\n      windowSizeReached  : Bool;\n      error  : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR \n      statValues  : Array[#ZERO_INT..#MAX_WINDOW_SIZE] of LReal;\n      statValuesSum  : LReal := 0.0;\n      statArithmeticAverage  : LReal := 0.0;\n      statWindowSizeOld  : Int := 0;\n      statCounter  : Int := 0;\n      statwindowSizeReached  : Bool;\n      statTriggerOld  : Bool := false;\n   END_VAR\n\n   VAR_TEMP \n      tempValue : LReal;\n      tempIndex : Int;\n      tempTriggerEdge : Bool;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO_INT : Int := 0;\n      ZERO_LREAL : LReal := 0.0;\n      MAX_WINDOW_SIZE : Int := 100;\n      INCREMENT : Int := 1;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_WRONG_WINDOW_SIZE : Word := 16#8200;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            FloatingAverage\n\t  // Comment/Function: This function block calculates the floating arithmetic average\n\t  //                   of incoming REAL values each cycle or each trigger impulse.\n\n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION DESCRIPTION\n\t  (/**/)\n\tEND_REGION DESCRIPTION\n\t\n\tREGION Initialization and input data processing\n\t  // Copy commonly used data to temp variables\n\t  #tempValue := #value;\n\t  \n\t  // Positive edge detection for triggering of calculation\n\t  #tempTriggerEdge := #trigger AND NOT #statTriggerOld;\n\t  #statTriggerOld := #trigger;\n\t  \n\t  // Reset OR if window size changes the calculation\n\t  IF #reset OR (#windowSize <> #statWindowSizeOld) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #windowSizeReached := FALSE;\n\t    #statwindowSizeReached := FALSE;\n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    RETURN;\n\t    \n\t    // Check window size, in case of incorrect window size setup an error\n\t  ELSIF (#windowSize <= #ZERO_INT) OR (#windowSize > #MAX_WINDOW_SIZE) THEN\n\t    #statWindowSizeOld := #windowSize;\n\t    #statCounter := #ZERO_INT;\n\t    #statValuesSum := #ZERO_LREAL;\n\t    #statArithmeticAverage := #ZERO_LREAL;\n\t    #average := #ZERO_LREAL;\n\t    #statwindowSizeReached := FALSE;\n\t    #windowSizeReached := FALSE;\n\t    #error := TRUE;\n\t    #status := #ERR_WRONG_WINDOW_SIZE; // Info \"No correct set of window size\"\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Floating average calculation\n\t  // Triggered calculation OR cyclicly operation\n\t  IF #cyclicExecution OR #tempTriggerEdge THEN\n\t    \n\t    //Calculate array counter by using modulo\n\t    #tempIndex := #statCounter MOD #windowSize;\n\t    \n\t    // First step - fill the Array with values\n\t    // as long as desired window size is not reached\n\t    // counter and array starts with zero\n\t    IF (#statCounter < #windowSize) THEN\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue;\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Increment counter\n\t      #statCounter += #INCREMENT;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #statCounter;\n\t      \n\t    ELSE\n\t      // wuindow size is reached, set output\n\t      #statwindowSizeReached := TRUE;\n\t      // Add value to sum\n\t      #statValuesSum += #tempValue - #statValues[#tempIndex];\n\t      // Add value to window\n\t      #statValues[#tempIndex] := #tempValue;\n\t      // Calculate avarage value\n\t      #statArithmeticAverage := #statValuesSum / #windowSize;\n\t      \n\t      // Manipulate counter value of window if modulo calc result is zero\n\t      IF (#tempIndex = #ZERO_INT) THEN\n\t        #statCounter := #windowSize + #INCREMENT;\n\t      ELSE\n\t        // Increment counter\n\t        #statCounter += #INCREMENT;\n\t      END_IF;\n\t    END_IF;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #average := #statArithmeticAverage;\n\t  #windowSizeReached := #statwindowSizeReached;\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  \n\t  // ENO mechanism is not used - forced to true\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": [], "ID": 14, "cot": "1. 检查复位信号，如果为TRUE，则重置所有变量并退出。\n2. 检查窗口大小，如果小于1或大于100，则设置错误状态并退出。\n3. 检查周期执行信号或触发信号的上升沿，如果其中任何一个为TRUE，则读取新数据并更新移动平均值。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        cyclicExecution : Bool;    //为TRUE时，周期性读取，trigger不起作用\n        trigger : Bool;    //外部触发信号，每次上升沿读取value\n        value : LReal;    //新读取的数据值\n        windowSize : Int;    //移动平均值的窗口大小，要求范围在1到100之间\n        reset : Bool;    //复位信号，当为TRUE时重置移动平均值计算\n    END_VAR\n\n    VAR_OUTPUT\n        average : LReal;    //移动平均值\n        windowSizeReached : Bool;    //FALSE:尚未达到最大窗口宽度 TRUE:已经达到最大窗口宽度\n        error : Bool;    //FALSE:没有发生错误 TRUE:执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "积分功能", "description": "编写一个函数块FB，该函数块实现输入信号的积分功能，并带有启动和复位功能。积分是对输入信号随时间的累积求和，通常用于计算流量、位移等物理量的累积值。启动功能用于开始积分计算，而复位功能用于将积分值重置为零。\n当读取系统时间出错时，则输出错误状态和错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#8600：读取系统时间错误", "type": "FUNCTION_BLOCK", "name": "Integration", "input": [{"name": "enable", "type": "Bool", "description": "启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。"}, {"name": "value", "type": "LReal", "description": "需要积分的输入信号值"}, {"name": "reset", "type": "Bool", "description": "复位信号，当该信号为TRUE时，将积分值重置为零"}], "output": [{"name": "integral", "type": "LReal", "description": "积分值"}, {"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "answer": "﻿FUNCTION_BLOCK \"Integration\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      enable : Bool;\n      value : LReal;\n      reset : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      integral : LReal;\n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR \n      statLastTime  : DTL;\n      statInputOldValue : LReal;\n      statIntegral : LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempSysTime  : DTL;\n      tempTimeDiffrence : LReal;\n      tempCalculation : LReal;\n      tempRetval : Word;\n   END_VAR\n\n   VAR CONSTANT \n      CLEAR_TIME  : DTL;\n      SECOND_IN_MS : LReal := 1000.0;\n      DIVIDE_BY_TWO : LReal := 2.0;\n      ZERO : LReal := 0.0;\n      STATUS_EXECUTION_FINISHED_NO_ERROR : Word := 16#0000;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      ERR_READ_SYS_TIME : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //============================================================================\n\t    // Title:            Integration\n\t    // Comment/Function: Integrates the input value\n\t    //                   integration by trapezoidal rule\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\t//Reset region must be before the enable region so that even if the function disabled, the user can reset the values.\n\tREGION Reset the function\n\t    IF #reset THEN\n\t        #statInputOldValue := #ZERO;\n\t        #statIntegral := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #ZERO;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Reset the function\n\t\n\tREGION Enable/Disable integral calculation\n\t    IF NOT #enable THEN\n\t        #statInputOldValue := #ZERO;\n\t        \n\t        // Clear LastTime value.\n\t        // If it is not cleared when the function is enabled again,\n\t        // the first value will be multiplied with the time difference of the whole disable time\n\t        // Initial condition - first Delta time will be 0.\n\t        #statLastTime := #CLEAR_TIME;\n\t        \n\t        #integral := #statIntegral;\n\t        #error := false;\n\t        #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t        \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION Enable/Disable integral calculation\n\t\n\tREGION Get system time\n\t    // Read system time\n\t    #tempRetval := INT_TO_WORD(RD_SYS_T(OUT => #tempSysTime));\n\t    \n\t    // Error Handling read system time\n\t    IF (#tempRetval > #SUB_STATUS_NO_ERROR) THEN\n\t        #integral := #statIntegral;\n\t        #error := TRUE;\n\t        #status := #ERR_READ_SYS_TIME;\n\t       \n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating the integral\n\t    // Calculate time difference between last and actual time\n\t    // coverting from DTL via time and DInt to Real\n\t    // scale from millisecond to second\n\t    #tempTimeDiffrence := DINT_TO_REAL(TIME_TO_DINT(T_DIFF(IN1 := #tempSysTime, IN2 := #statLastTime))) / #SECOND_IN_MS;\n\t    \n\t    // Write actual to last time\n\t    #statLastTime := #tempSysTime;\n\t    \n\t    // integration by trapezoidal rule\n\t    // add LastScalIn to ScalIn\n\t    // divide by two --> avarage of both - old and actual value\n\t    // multiply with time delta --> area unterneath the both borders\n\t    #tempCalculation := (#value + #statInputOldValue) * #tempTimeDiffrence / #DIVIDE_BY_TWO;\n\t    \n\t    // Calculate new integral\n\t    #statIntegral += #tempCalculation;\n\t    \n\t    // Save last input\n\t    #statInputOldValue := #value;\n\tEND_REGION Calculating the integral\n\t\n\tREGION Write outputs\n\t    #integral := #statIntegral;\n\t    #error := false;\n\t    #status := #STATUS_EXECUTION_FINISHED_NO_ERROR;\n\t    \n\t    \n\t    //ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION Write outputs\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": [], "ID": 15, "cot": "1. 定义一个变量lastTime用于存储上一次计算积分的时间。\n2. 定义一个变量lastValue用于存储上一次计算积分的输入值。\n3. 检查启动信号enable，如果为TRUE，则开始积分计算；如果为FALSE，则停止积分计算，并将integral输出显示为最后一次计算的值。\n4. 检查复位信号reset，如果为TRUE，则将积分值integral重置为零。\n5. 读取系统时间，如果读取成功，则将当前时间与lastTime的差值与输入值value的乘积累加到积分值integral上，并将当前时间和输入值分别存储到lastTime和lastValue中；如果读取失败，则将错误状态error设置为TRUE，并将状态代码status设置为16#8600。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        enable : Bool;    //启动信号，当该信号为TRUE时，启用积分计算；如果为FALSE，积分计算将停止，integral输出将显示最后一次计算的值。\n        value : LReal;    //需要积分的输入信号值\n        reset : Bool;    //复位信号，当该信号为TRUE时，将积分值重置为零\n    END_VAR\n\n    VAR_OUTPUT\n        integral : LReal;    //积分值\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "灯控程序", "description": "编写一个函数块FB，实现一个灯控功能。\n某控制台有3个指示灯，要求通过3个按钮开关进行控制。\n\n1. 输入参数#button1~#button3表示3个按钮开关，输出参数#greenLight、#redLight、#yellowLight表示指示灯。\n2. 当#button1=0时，表示手动模式，指示灯根据#button2和#button3的操作组合进行不同状态显示：\n   - 当#button2和#button3都为0时，所有指示灯熄灭（#greenLight、#redLight、#yellowLight都为0）。\n   - 当#button2为1且#button3为0时，#greenLight常亮，并且#redLight以0.5Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2为0且#button3为1时，#redLight常亮，并且#yellowLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n   - 当#button2和#button3都为1时，#yellowLight常亮，并且#greenLight以1Hz的频率闪烁，即1秒灭，1秒亮。\n3. 当#button1=1时，表示自动模式，指示灯自动按照如下说明循环执行：\n   - 首先#greenLight亮，保持1秒。\n   - 然后#greenLight熄灭，#redLight亮，保持1秒。\n   - 然后#redLight熄灭，#yellowLight亮，保持1秒。\n   - 然后回到初始状态#greenLight亮，保持1秒，如此循环。", "type": "FUNCTION_BLOCK", "name": "LightsControl", "input": [{"name": "button1", "type": "Bool", "description": "按钮1"}, {"name": "button2", "type": "Bool", "description": "按钮2"}, {"name": "button3", "type": "Bool", "description": "按钮3"}], "output": [{"name": "greenLight", "type": "Bool", "description": "绿灯"}, {"name": "redLight", "type": "Bool", "description": "红灯"}, {"name": "yellowLight", "type": "Bool", "description": "黄灯"}], "answer": "﻿FUNCTION_BLOCK \"LightsControl\"\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      button1 : Bool;\n      button2 : Bool;\n      button3 : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      greenLight : Bool;\n      redLight : Bool;\n      yellowLight : Bool;\n   END_VAR\n\n   VAR \n      CycleStep : Int := 0;\n      ManModeTimer1 : TON_TIME;\n      ManModeTimer2 : TON_TIME;\n      AutoModeTimer : TON_TIME;\n   END_VAR\n\n\nBEGIN\n\t    IF #button1 = FALSE THEN\n\t        #ManModeTimer1(IN := #ManModeTimer2.Q,\n\t                       PT := t#1s);\n\t        #ManModeTimer2(IN := NOT #ManModeTimer1.Q,\n\t                       PT := t#1s);\n\t        IF #button2 AND NOT #button3 THEN\n\t            #greenLight := TRUE;\n\t            #redLight := #ManModeTimer2.Q;\n\t            #yellowLight := FALSE;\n\t        ELSIF NOT #button2 AND #button3 THEN\n\t            #redLight := TRUE;\n\t            #yellowLight := #ManModeTimer2.Q;\n\t            #greenLight := FALSE;\n\t        ELSIF #button2 AND #button3 THEN\n\t            #yellowLight := TRUE;\n\t            #greenLight := #ManModeTimer2.Q;\n\t            #redLight := FALSE;\n\t        ELSE\n\t            #greenLight := FALSE;\n\t            #redLight := FALSE;\n\t            #yellowLight := FALSE;\n\t        END_IF;\n\t        \n\t    ELSE\n\t        #AutoModeTimer(IN := TRUE,\n\t                       PT := T#1s);\n\t        CASE #CycleStep OF\n\t            0:\n\t                #greenLight := TRUE;\n\t                #redLight := FALSE;\n\t                #yellowLight := FALSE;\n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 1;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            1:\n\t                #greenLight := FALSE;\n\t                #redLight := TRUE;\n\t                #yellowLight := FALSE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 2;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t            2:\n\t                #greenLight := FALSE;\n\t                #redLight := FALSE;\n\t                #yellowLight := TRUE;\n\t                \n\t                IF #AutoModeTimer.Q THEN\n\t                    #CycleStep := 0;\n\t                    #AutoModeTimer(IN := FALSE,\n\t                                   PT := T#1s);\n\t                END_IF;\n\t        END_CASE;\n\t    END_IF;\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": [], "ID": 16, "cot": "1. 定义输入输出参数，以及内部使用的变量。\n2. 判断#button1的状态，如果为0则进入手动模式，如果为1则进入自动模式。\n3. 在手动模式下，根据#button2和#button3的状态，控制指示灯的亮灭和闪烁。\n4. 在自动模式下，按照指定的顺序和时间，控制指示灯的亮灭。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        button1 : Bool;    //按钮1\n        button2 : Bool;    //按钮2\n        button3 : Bool;    //按钮3\n    END_VAR\n\n    VAR_OUTPUT\n        greenLight : Bool;    //绿灯\n        redLight : Bool;    //红灯\n        yellowLight : Bool;    //黄灯\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "矩阵加法", "description": "编写一个函数FC，实现两个矩阵的加法功能。\n\n该函数接受两个可变长度的二维浮点数数组matrix1和matrix2作为输入参数。函数应检查两个输入矩阵以及用于返回结果的输出矩阵是否具有相同的行数和列数，如果不相同，则返回错误状态和特定的错误代码。\n\n状态代码：\n16#0000：执行FB没有出错\n16#8200：第一矩阵数组行的下界值与第二矩阵行的下界值不同\n16#8201：第一矩阵数组行的下界值与结果矩阵行的下界值不同\n16#8202：第一矩阵数组列的下界值与第二矩阵列的下界值不同\n16#8203：第一矩阵数组列的下界值与结果矩阵列的下界值不同\n16#8204：第一矩阵数组行的上界值与第二矩阵行的上界值不同\n16#8205：第一矩阵数组行的上界值与结果矩阵行的上界值不同\n16#8206：第一矩阵数组列的上界值与第二矩阵列的上界值不同\n16#8207：第一矩阵数组列的上界值与结果矩阵列的上界值不同", "type": "FUNCTION", "name": "MatrixAddition", "input": [{"name": "matrix1", "type": "Array[*, *] of LReal", "description": "第一矩阵"}, {"name": "matrix2", "type": "Array[*, *] of LReal", "description": "第二矩阵"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "matrixResult", "type": "Array[*, *] of LReal", "description": "存放计算结果的矩阵"}], "answer": "﻿FUNCTION \"MatrixAddition\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      matrix1 : Array[*, *] of LReal;\n      matrix2 : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      matrixResult : Array[*, *] of LReal;\n   END_VAR\n\n   VAR_TEMP \n      tempMatrix1LowerBoundRows : DInt;\n      tempMatrix1LowerBoundColumns : DInt;\n      tempMatrix1UpperBoundRows : DInt;\n      tempMatrix1UpperBoundColumns : DInt;\n      tempMatrix2LowerBoundRows : DInt;\n      tempMatrix2LowerBoundColumns : DInt;\n      tempMatrix2UpperBoundRows : DInt;\n      tempMatrix2UpperBoundColumns : DInt;\n      tempResultMatrixLowerBoundRows : DInt;\n      tempResultMatrixLowerBoundColumns : DInt;\n      tempResultMatrixUpperBoundRows : DInt;\n      tempResultMatrixUpperBoundColumns : DInt;\n      tempCounterRows : DInt;\n      tempCounterColumns : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ROWS : UInt := 1;\n      COLUMNS : UInt := 2;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS : Word := 16#8200;\n      ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS : Word := 16#8201;\n      ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS : Word := 16#8202;\n      ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS : Word := 16#8203;\n      ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS : Word := 16#8204;\n      ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS : Word := 16#8205;\n      ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS : Word := 16#8206;\n      ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS : Word := 16#8207;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            MatrixAddition\n\t  // Comment/Function: Caluclates the sum of two matrices\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Getting matrices size\n\t  //Determine the size of the matrices\n\t  // Lower bound rows\n\t  #tempMatrix1LowerBoundRows := LOWER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2LowerBoundRows := LOWER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixLowerBoundRows := LOWER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Lower bound columns\n\t  #tempMatrix1LowerBoundColumns := LOWER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2LowerBoundColumns := LOWER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixLowerBoundColumns := LOWER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\t  \n\t  // Upper bound rows\n\t  #tempMatrix1UpperBoundRows := UPPER_BOUND(ARR := #matrix1, DIM := #ROWS);\n\t  #tempMatrix2UpperBoundRows := UPPER_BOUND(ARR := #matrix2, DIM := #ROWS);\n\t  #tempResultMatrixUpperBoundRows := UPPER_BOUND(ARR := #matrixResult, DIM := #ROWS);\n\t  // Upper bound columns\n\t  #tempMatrix1UpperBoundColumns := UPPER_BOUND(ARR := #matrix1, DIM := #COLUMNS);\n\t  #tempMatrix2UpperBoundColumns := UPPER_BOUND(ARR := #matrix2, DIM := #COLUMNS);\n\t  #tempResultMatrixUpperBoundColumns := UPPER_BOUND(ARR := #matrixResult, DIM := #COLUMNS);\n\tEND_REGION\n\t\n\tREGION Error evaluation of matrixes dimentions\n\t  //Check the lower bound of all matrices\n\t  IF (#tempMatrix1LowerBoundRows <> #tempMatrix2LowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_MATR2_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundRows <> #tempResultMatrixLowerBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_ROWS_RESMATR_LOWBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempMatrix2LowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_MATR2_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1LowerBoundColumns <> #tempResultMatrixLowerBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_LOWBOUND_COLUMNS_RESMATR_LOWBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\t  //Check the upper bound of all matrices\n\t  IF (#tempMatrix1UpperBoundRows <> #tempMatrix2UpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_MATR2_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundRows <> #tempResultMatrixUpperBoundRows) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_ROWS_RESMATR_UPPBOUND_ROWS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempMatrix2UpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_MATR2_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  ELSIF (#tempMatrix1UpperBoundColumns <> #tempResultMatrixUpperBoundColumns) THEN\n\t    #error := TRUE;\n\t    #status := #ERR_MATR1_UPPBOUND_COLUMNS_RESMATR_UPPBOUND_COLUMNS;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Addition of the matrices and writting to output\n\t  FOR #tempCounterRows := #tempMatrix1LowerBoundRows TO #tempMatrix1UpperBoundRows DO\n\t    FOR #tempCounterColumns := #tempMatrix1LowerBoundColumns TO #tempMatrix1UpperBoundColumns DO\n\t      #matrixResult[#tempCounterRows, #tempCounterColumns] := #matrix1[#tempCounterRows, #tempCounterColumns] + #matrix2[#tempCounterRows, #tempCounterColumns];\n\t    END_FOR;\n\t  END_FOR;\n\t  \n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  // ENO mechanism is not used\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "return_value": [{"type": "Void", "description": ""}], "ID": 17, "cot": "1. 检查两个输入矩阵和输出矩阵的行数和列数是否相同\n2. 如果不同，返回错误状态和特定的错误代码\n3. 如果相同，进行矩阵加法运算\n4. 将结果存入输出矩阵\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        matrix1 : Array[*, *] of LReal;    //第一矩阵\n        matrix2 : Array[*, *] of LReal;    //第二矩阵\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        matrixResult : Array[*, *] of LReal;    //存放计算结果的矩阵\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "随机数", "description": "编写一个函数FC，该函数使用PLC的时钟值在指定的范围内生成一个随机整数。\n如果指定的范围不正确或读取系统时间出错，则输出错误状态和错误代码。\n\n状态代码\n16#0000：执行FB没有出错\n16#8200：指定的范围不正确：minValue 大于 maxValue\n16#8600：读取系统时间错误", "type": "FUNCTION", "name": "RandomRange_DInt", "input": [{"name": "minValue", "type": "DInt", "description": "随机数范围的最小值"}, {"name": "maxValue", "type": "DInt", "description": "随机数范围的最大值"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "DInt", "description": "产生的随机数"}], "answer": "﻿FUNCTION \"RandomRange_DInt\" : DInt\n{ S7_Optimized_Access := 'TRUE' }\nVERSION : 0.1\n   VAR_INPUT \n      minValue : DInt;\n      maxValue : DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempTime  : DTL;\n      tempNanoSecondInDWord : DWord;\n      tempTimeStatus : Word;\n      tempRandomValue : DWord;\n      tempNormReal : Real;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : DInt := 0;\n      MAX_UDINT : UDInt := 4_294_967_295;\n      SUB_STATUS_NO_ERROR : Word := 16#0000;\n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_MAX_LESS_MIN : Word := 16#8200;\n      ERR_RD_SYS_T : Word := 16#8600;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t    //=============================================================================\n\t    // Title:            RandomRange_DInt\n\t    // Comment/Function: This function generates random numbers in defined limits (Datatype DInt)\n\t    \n\t    //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation\n\t    // Check if the maximal Value is less than the minimal value\n\t    IF (#minValue > #maxValue) THEN\n\t        #error := true;\n\t        #status := #ERR_MAX_LESS_MIN;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\t    \n\t    // Read system time\n\t    #tempTimeStatus := INT_TO_WORD(RD_SYS_T(#tempTime));\n\t    \n\t    // Check return variable for error\n\t    IF (#tempTimeStatus <> #SUB_STATUS_NO_ERROR) THEN\n\t        #error := true;\n\t        #status := #ERR_RD_SYS_T;\n\t        \n\t        #RandomRange_DInt := #ZERO;\n\t        RETURN;\n\t    END_IF;\n\tEND_REGION\n\t\n\tREGION Calculating random number\n\t    // Converting to double word so individual bytes can be addressed\n\t    #tempNanoSecondInDWord := UDINT_TO_DWORD(#tempTime.NANOSECOND);\n\t    \n\t    // Callculate a random-start-value depending on the time\n\t    #tempRandomValue.%B3 := #tempNanoSecondInDWord.%B0;\n\t    #tempRandomValue.%B2 := #tempNanoSecondInDWord.%B1;\n\t    #tempRandomValue.%B1 := #tempNanoSecondInDWord.%B2;\n\t    #tempRandomValue.%B0 := #tempNanoSecondInDWord.%B3;\n\t    \n\t    // Norm the calculated random number: 0.0 <= #tempNormReal <= 1.0\n\t    #tempNormReal := UDINT_TO_REAL(DWORD_TO_UDINT(#tempRandomValue)) / UDINT_TO_REAL(#MAX_UDINT);\n\t    \n\t    // Scale the tempNormReal to be in the range of maxValue and minValue\n\t    #RandomRange_DInt := REAL_TO_DINT((#tempNormReal * DINT_TO_REAL(#maxValue - #minValue) + DINT_TO_REAL(#minValue)));\n\t    \n\t    #error := false;\n\t    #status := #STATUS_FINISHED_NO_ERROR;\n\t    \n\t    // ENO mechanism is not used\n\t    ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": [], "ID": 18, "cot": "1. 检查输入的范围是否正确，即minValue是否小于等于maxValue。如果不正确，则设置错误状态为16#8200，并返回。\n2. 读取PLC的系统时间。如果读取失败，则设置错误状态为16#8600，并返回。\n3. 使用系统时间作为种子生成一个随机数。\n4. 将生成的随机数限制在指定的范围内，并返回。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        minValue : DInt;    //随机数范围的最小值\n        maxValue : DInt;    //随机数范围的最大值\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "查找最大最小值", "description": "编写一个函数FC，该函数能够接收一个可变长度的整数数组作为输入，并返回数组中的最大值和最小值以及他们所在数组的位置。\n\n示例：\n假设输入数组为array[1..5]=[5, 10, 2, 25, 1]，函数应返回最大值25，最小值1，最大值所在位置4，最小值所在位置5。", "type": "FUNCTION", "name": "SearchMinMax_DInt", "input": [{"name": "values", "type": "Array[*] of DInt", "description": "待查找的数组"}], "output": [{"name": "minValue", "type": "DInt", "description": "数组中的最小值"}, {"name": "minValueIndex", "type": "DInt", "description": "最小值在数组中的位置"}, {"name": "maxValue", "type": "DInt", "description": "数组中的最大值"}, {"name": "maxValueIndex", "type": "DInt", "description": "最大值在数组中的位置"}], "answer": "﻿FUNCTION \"SearchMinMax_DInt\" : Void\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      values : Array[*] of DInt;\n   END_VAR\n\n   VAR_OUTPUT \n      minValue : DInt;\n      minValueIndex : DInt;\n      maxValue : DInt;\n      maxValueIndex : DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempArrayLowerBound : DInt;\n      tempArrayUpperBound : DInt;\n      tempCounter : DInt;\n      tempArrayIndexMax : DInt;\n      tempArrayIndexMin : DInt;\n      tempActValue : DInt;\n      tempMinValue : DInt;\n      tempMaxValue : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      START_FROM_SECOND_ELEMENT : Int := 1;\n      DIMENSION_ONE : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            SearchMinMax_DInt\n\t  // Comment/Function: Searches an array for the minimum and maximum number and\n\t  //                   outputs the position and values of those numbers for\n\t  //                   array of double integers\n\t \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Validation of inputs and outputs \n\t  // Lower bound\n\t  #tempArrayLowerBound := LOWER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\t  // Upper bound \n\t  #tempArrayUpperBound := UPPER_BOUND(ARR := #values, DIM := #DIMENSION_ONE);\n\tEND_REGION\n\t\n\tREGION Searching the array \n\t  // Assign first value as min / max\n\t  #tempMinValue := #tempMaxValue := #values[#tempArrayLowerBound];\n\t  #tempArrayIndexMin := #tempArrayIndexMax := #tempArrayLowerBound;\n\t  \n\t  // Search the Array for min/max values\n\t  FOR #tempCounter := (#tempArrayLowerBound + #START_FROM_SECOND_ELEMENT) TO #tempArrayUpperBound DO\n\t    \n\t    #tempActValue := #values[#tempCounter];\n\t    \n\t    // check for min\n\t    IF #tempActValue < #tempMinValue THEN\n\t      #tempMinValue := #tempActValue;\n\t      #tempArrayIndexMin := #tempCounter;\n\t      // check for max\n\t    ELSIF #tempActValue > #tempMaxValue THEN\n\t      #tempMaxValue := #tempActValue;\n\t      #tempArrayIndexMax := #tempCounter;\n\t    END_IF;\n\t  END_FOR;\n\tEND_REGION\n\t\n\tREGION Writting to outputs\n\t  // Copy found values to outputs\n\t  // Copy Minimum value\n\t  #minValue := #values[#tempArrayIndexMin];\n\t  // Copy Maximum value\n\t  #maxValue := #values[#tempArrayIndexMax];\n\t  \n\t  // Write found indexes to outputs\n\t  #minValueIndex := #tempArrayIndexMin;\n\t  #maxValueIndex := #tempArrayIndexMax;\n\t  \n\t  // ENO mechanism is not used, no error possible\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": [], "return_value": [{"type": "Void", "description": ""}], "ID": 19, "cot": "1. 初始化最大值和最小值为数组的第一个元素，最大值和最小值的位置为1。\n2. 遍历数组，如果当前元素大于最大值，则更新最大值和最大值的位置；如果当前元素小于最小值，则更新最小值和最小值的位置。\n3. 返回最大值、最小值以及他们在数组中的位置。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        values : Array[*] of DInt;    //待查找的数组\n    END_VAR\n\n    VAR_OUTPUT\n        minValue : DInt;    //数组中的最小值\n        minValueIndex : DInt;    //最小值在数组中的位置\n        maxValue : DInt;    //数组中的最大值\n        maxValueIndex : DInt;    //最大值在数组中的位置\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "生成脉冲信号", "description": "编写一个函数块FB，该函数块生成一个周期性的信号，该信号在FALSE和TRUE之间变化。每个周期中TRUE状态的持续时间和FALSE状态的持续时间由给定的频率和脉冲间歇比决定。脉冲间歇比定义的是每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。\n\n示例：\n假设frequency为0.5Hz，pulsePauseRatio为3。这意味着每个周期是2秒，其中TRUE状态持续1.5秒，FALSE状态持续0.5秒。", "type": "FUNCTION_BLOCK", "name": "Frequency", "input": [{"name": "frequency", "type": "Real", "description": "以Hz为单位的时钟频率"}, {"name": "pulsePauseRatio", "type": "Real", "description": "脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。"}], "output": [{"name": "clock", "type": "Bool", "description": "脉冲输出"}, {"name": "countdown", "type": "Time", "description": "当前状态的剩余时间"}], "answer": "﻿FUNCTION_BLOCK \"Frequency\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      frequency : Real := 0.0;\n      pulsePauseRatio : Real := 1.0;\n   END_VAR\n\n   VAR_OUTPUT \n      clock  : Bool;\n      countdown  : Time;\n   END_VAR\n\n   VAR \n      instTofTimePulse  : TOF_TIME;\n      instTofTimePause  : TOF_TIME;\n      statFrequencyOld  : Real;\n      statPulsePauseRatioOld : Real;\n      statTimePulse  : Time;\n      statTimePause  : Time;\n   END_VAR\n\n   VAR_TEMP \n      tempPulseRate : Real;\n      tempPauseRate : Real;\n      tempCountdown : Time;\n   END_VAR\n\n   VAR CONSTANT \n      ZERO : Real := 0.0;\n      ZERO_TIME : Time := T#0ms;\n      SECOND_IN_MS : Real := 1000.0;\n      ONE : Real := 1.0;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //=============================================================================\n\t  // Title:            Frequency\n\t  // Comment/Function: This function generates a signal that changes between the values `FALSE` and `TRUE` depending on a defined frequency and a pulse pause ratio.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Calculation of settings and program execution\n\t  // If input <= 0.0 the block is disabled\n\t  IF (#frequency <= #ZERO) OR (#pulsePauseRatio <= #ZERO) THEN\n\t    #clock := FALSE;\n\t    #tempCountdown := #ZERO_TIME;\n\t  ELSE\n\t    \n\t    //Calculating function frequency and pulse pause ratio only when an input is changed\n\t    IF #statFrequencyOld <> #frequency OR #statPulsePauseRatioOld <> #pulsePauseRatio THEN\n\t      RESET_TIMER(TIMER := #instTofTimePause);\n\t      RESET_TIMER(TIMER := #instTofTimePulse);\n\t      \n\t      #tempPulseRate := #pulsePauseRatio / (#pulsePauseRatio + #ONE); // Calculate pulse rate   \n\t      #tempPauseRate := #ONE - #tempPulseRate;                      // Calculate pause rate   \n\t      #statTimePulse := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPulseRate / #frequency))); // Calculate pulse time   \n\t      #statTimePause := UDINT_TO_TIME(REAL_TO_UDINT((#SECOND_IN_MS * #tempPauseRate / #frequency))); // Calculate pause time\n\t      #statFrequencyOld := #frequency;\n\t      #statPulsePauseRatioOld := #pulsePauseRatio;\n\t    END_IF;\n\t    \n\t    //Two time off-delay timers that are resetting each other on expiration\n\t    #instTofTimePulse(IN := NOT #instTofTimePause.Q,\n\t                      PT := #statTimePulse);\n\t    \n\t    //If timer for pulse is running, remaining time of the PULSE is calculated\n\t    #tempCountdown := #statTimePulse - #instTofTimePulse.ET;\n\t    \n\t    #instTofTimePause(IN := #instTofTimePulse.Q,\n\t                      PT := #statTimePause);\n\t    \n\t    //If timer for pulse is NOT running, remaining time of the PAUSE is calculated\n\t    IF #tempCountdown = #ZERO_TIME THEN\n\t      #tempCountdown := #statTimePause - #instTofTimePause.ET;\n\t    END_IF;\n\t    \n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Writing to outputs\n\t  // Assigning value of the pulse timer to the clock output\n\t  #clock := #instTofTimePulse.Q;\n\t  #countdown := #tempCountdown;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "in/out": [], "return_value": [], "ID": 20, "cot": "1. 计算周期时间，即1/frequency。\n2. 计算TRUE状态和FALSE状态的持续时间，即周期时间乘以脉冲间歇比和1减去脉冲间歇比。\n3. 使用系统时间来判断当前应该处于TRUE状态还是FALSE状态，并更新剩余时间。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        frequency : Real;    //以Hz为单位的时钟频率\n        pulsePauseRatio : Real;    //脉冲间歇比，定义为每个周期中TRUE状态的持续时间与FALSE状态的持续时间之比。例如，如果pulsePauseRatio为2，则TRUE状态的持续时间将是FALSE状态的两倍。\n    END_VAR\n\n    VAR_OUTPUT\n        clock : Bool;    //脉冲输出\n        countdown : Time;    //当前状态的剩余时间\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "排序", "description": "编写一个函数块FB，实现一个可选的升序或降序排序功能。该函数块应接受一个可变长度的整数数组（最大长度为1000个元素）以及一个指示排序方向的参数（升序或降序），并将排序后的结果写回到原数组中。如果数组元素超过了1000或不超过1个，函数块应输出一个表示错误的状态和一个错误代码。状态代码：\n16#0000：执行FB没有出错\n16#8200：数组元素没超过1个\n16#8201：数组元素超过了1000个", "type": "FUNCTION_BLOCK", "name": "ShellSort_DInt", "input": [{"name": "sortDirection", "type": "Bool", "description": "当为FALSE时表示升序排列，当为TRUE时表示降序排列"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "array", "type": "Array[*] of DInt", "description": "待排序的数组"}], "answer": "﻿FUNCTION_BLOCK \"ShellSort_DInt\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      sortDirection : Bool;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status  : Word;\n   END_VAR\n\n   VAR_IN_OUT \n      \"array\" : Array[*] of DInt;\n   END_VAR\n\n   VAR \n      tempArray : Array[1..#MAX_ARRAY_ELEMENTS] of DInt;\n   END_VAR\n\n   VAR_TEMP \n      tempLowerLimit : DInt;\n      tempUpperLimit : DInt;\n      tempNoOfElements : DInt;\n      tempGap : DInt;\n      tempLoopIndex : DInt;\n      tempExchangeIndex : DInt;\n      tempExchangeVariable : DInt;\n      tempArrayOffset : DInt;\n   END_VAR\n\n   VAR CONSTANT \n      ARRAY_FIRST_DIMENSION : UInt := 1;\n      ARRAY_START_INDEX : UInt := 1;\n      SINGLE_ARRAY_ELEMENT : DInt := 1;\n      GAP_INIT : Int := 1;\n      GAP_THRESHOLD : Int := 1;\n      GAP_RATIO : DInt := 3;\n      INCREMENT : Int := 1;\n      ELEMENTS_COUNT_CORRECTION : DInt := 1;\n      MAX_ARRAY_ELEMENTS : Int := 1000;\n      STATUS_NO_ERROR : Word := 16#0000;\n      ERR_NO_ARRAY : Word := 16#8200;\n      ERR_TOO_MANY_ELEMENTS : Word := 16#8201;\n   END_VAR\n\n\nBEGIN\n\tREGION Block info header\n\t  //===============================================================================\n\t  // Title:            ShellSort_DInt\n\t  // Comment/Function: This block sorts an array with any number of elements (max. 1000)\n\t  //                   in ascending or descending order and returns the sorted version of the array in the same variable.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Special description\n\t  // Space note: If you wish to reduce the space of this block, you may reduce the\n\t  // size OF the tempArray<Type> TO one just big enough FOR your specific purpose\n\t  // It is not recommended to increase the size significantly.\n\tEND_REGION\n\t\n\tREGION Initialization and input data processing\n\t  // Input array size calculation\n\t  #tempLowerLimit := LOWER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  #tempUpperLimit := UPPER_BOUND(ARR := #array, DIM := #ARRAY_FIRST_DIMENSION);\n\t  \n\t  // Array elements calculation\n\t  // (for example: 6 - 2 = 4; but real number of elements is 5)\n\t  #tempNoOfElements := #tempUpperLimit - #tempLowerLimit + #ELEMENTS_COUNT_CORRECTION;\n\t  \n\t  // Shift array index to range 1..MAX_ARRAY_ELEMENTS\n\t  #tempArrayOffset := - #tempLowerLimit + #ARRAY_START_INDEX;\n\t  \n\t  // Check whether the array contains less than the maximum possible amount of elements\n\t  IF #tempNoOfElements > #MAX_ARRAY_ELEMENTS THEN\n\t    #error := true;\n\t    #status := #ERR_TOO_MANY_ELEMENTS;\n\t    RETURN;\n\t  ELSIF #tempNoOfElements <= #SINGLE_ARRAY_ELEMENT THEN\n\t    // If there are 0 elements in the array, set status to \"Error: Parameter is an empty array\"\n\t    #error := true;\n\t    #status := #ERR_NO_ARRAY;\n\t    RETURN;\n\t  END_IF;\n\tEND_REGION\n\t\n\tREGION Sorting\n\t  // Read the elements of the incoming array and write into the local array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #tempArray[#tempLoopIndex + #tempArrayOffset] := #array[#tempLoopIndex];\n\t  END_FOR;\n\t  \n\t  REGION Shell sort algorithm\n\t    #tempGap := #GAP_INIT;\n\t    \n\t    // Evaluation of the maximal gap size\n\t    REPEAT\n\t      #tempGap := (#GAP_RATIO * #tempGap) + #INCREMENT;\n\t    UNTIL #tempGap > #tempNoOfElements END_REPEAT;\n\t    \n\t    REPEAT\n\t      #tempGap := #tempGap / #GAP_RATIO;\n\t      \n\t      FOR #tempLoopIndex := #tempGap + #INCREMENT TO #tempNoOfElements DO\n\t        #tempExchangeVariable := #tempArray[#tempLoopIndex];\n\t        #tempExchangeIndex := #tempLoopIndex;\n\t        \n\t        // sort descending \n\t        IF #sortDirection THEN\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] < #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t          \n\t          // sort ascending\n\t        ELSE\n\t          WHILE ((#tempArray[#tempExchangeIndex - #tempGap] > #tempExchangeVariable)) DO\n\t            #tempArray[#tempExchangeIndex] := #tempArray[#tempExchangeIndex - #tempGap];\n\t            #tempExchangeIndex := #tempExchangeIndex - #tempGap;\n\t            \n\t            IF (#tempExchangeIndex <= #tempGap) THEN\n\t              EXIT;\n\t            END_IF;\n\t          END_WHILE;\n\t        END_IF;\n\t        \n\t        #tempArray[#tempExchangeIndex] := #tempExchangeVariable;\n\t      END_FOR;\n\t      \n\t    UNTIL #tempGap <= #GAP_THRESHOLD END_REPEAT;\n\t  END_REGION\n\t  \n\t  // Write the elements of the local array back to the inOut array\n\t  FOR #tempLoopIndex := #tempLowerLimit TO #tempUpperLimit DO\n\t    #array[#tempLoopIndex] := #tempArray[#tempLoopIndex + #tempArrayOffset];\n\t  END_FOR;\n\t  \n\t  // Set \"No error\" status\n\t  #error := false;\n\t  #status := #STATUS_NO_ERROR;\n\t  \n\t  // no error handling needed\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": [], "ID": 21, "cot": "1.检查输入数组的长度，如果长度超过1000或不超过1，设置错误状态并返回。\n2.使用希尔排序算法对数组进行排序。希尔排序是一种基于插入排序的快速排序算法，通过比较相距一定间隔的元素来工作，各趟比较所用的距离随着算法的进行而减小，直到只比较相邻元素的最后一趟排序为止。\n3.根据sortDirection参数，选择升序或降序排序。\n4.将排序后的数组写回到原数组中。\n5.如果没有错误，设置状态代码为16#0000。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        sortDirection : Bool;    //当为FALSE时表示升序排列，当为TRUE时表示降序排列\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        array : Array[*] of DInt;    //待排序的数组\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "特殊堆栈", "description": "编写一个函数块FB，实现一个特殊堆栈功能，在出栈时移除栈内的最小值。\n1. 入栈操作：当新元素入栈时，首先检查栈是否为满。如果栈为满，则不进行任何操作。否则，将其添加到数组的栈顶位置，并更新栈顶位置。\n2. 出栈操作：当执行出栈操作时，首先检查栈是否为空。如果栈为空，则不进行任何操作。否则，移除栈内的最小值，并返回该元素的值，同时更新栈顶位置。\n状态代码：\n16#0000：执行FB没有出错\n16#8A04：堆栈是满的\n16#8A05：堆栈是空的", "type": "FUNCTION_BLOCK", "name": "StackMin", "input": [{"name": "push", "type": "Bool", "description": "入栈操作，在栈未满的情况下，将一个元素添加到栈内"}, {"name": "pop", "type": "Bool", "description": "出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。"}, {"name": "reset", "type": "Bool", "description": "复位操作，栈顶位置将被重置。"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "in/out": [{"name": "item", "type": "Int", "description": "用于入栈或从栈内返回的值"}, {"name": "stack", "type": "Array[0..3] of Int", "description": "用于作为栈的数组"}], "answer": "﻿FUNCTION_BLOCK \"StackMin\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      push : Bool;   // 入栈\n      pop : Bool;   // 出栈\n      reset : Bool;   // 复位\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;   // 故障状态\n      status : Word;   // 状态代码\n   END_VAR\n\n   VAR_IN_OUT \n      item : Int;   // 入栈或出栈的元素\n      stack : Array[0..3] of Int;   // 堆栈空间\n   END_VAR\n\n   VAR \n      statStackIndex : Int;   // 堆栈指针\n      statMin : Int;\n   END_VAR\n\n   VAR_TEMP \n      tempStackSize : DInt;\n      tempCount : Int;\n   END_VAR\n\n   VAR CONSTANT \n      STACK_FULL : Word := 16#8A04;   // 堆栈已满\n      STACK_EMPTY : Word := 16#8A05;   // 堆栈已空\n      NO_ERROR : Word := 16#0000;\n   END_VAR\n\n\nBEGIN\n\t//设置堆栈长度\n\tREGION StackSize\n\t    #tempStackSize := 4;\n\tEND_REGION\n\t\n\t//入栈\n\tREGION Push\n\t    IF #push = TRUE THEN\n\t        IF #statStackIndex >= #tempStackSize THEN             //判断是否满栈，如果已经满栈,则不执行入栈,并报错\n\t            #error := TRUE;\n\t            #status := #STACK_FULL;\n\t            RETURN;\n\t        END_IF;\n\t        #stack[#statStackIndex] := #item;                    //否则放入元素\n\t        #statStackIndex += 1;                                //堆栈指针上移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//出栈\n\tREGION Pop\n\t    IF #pop = TRUE THEN\n\t        \n\t        //判断空栈，如果已经空栈,则不执行出栈,并报错\n\t        IF #statStackIndex <= 0 THEN                          \n\t            #error := TRUE;\n\t            #status := #STACK_EMPTY;\n\t            RETURN;\n\t        END_IF;\n\t        \n\t        //查找最小值所在位置\n\t        #statMin := 0;\n\t        IF #statStackIndex>1 THEN\n\t            FOR #tempCount := 1 TO #statStackIndex - 1 DO\n\t                IF #stack[#tempCount] < #stack[#statMin] THEN\n\t                    #statMin := #tempCount;\n\t                END_IF;\n\t            END_FOR;\n\t        END_IF;\n\t        \n\t        //取出元素，上面元素往下顺移\n\t        #item := #stack[#statMin];               \n\t        IF #statMin<>#statStackIndex-1 THEN\n\t            FOR #tempCount := #statMin TO #statStackIndex - 2 DO\n\t                #stack[#tempCount] := #stack[#tempCount + 1];\n\t            END_FOR;\n\t        END_IF;\n\t        #stack[#statStackIndex - 1] := 0;\n\t        #statStackIndex -= 1;                               //堆栈指针下移\n\t    END_IF;\n\tEND_REGION\n\t\n\t//复位\n\tREGION Reset\n\t    IF #reset = TRUE THEN\n\t        #statStackIndex := 0;\n\t    END_IF;\n\tEND_REGION\n\t\n\t#error := FALSE;\n\t#status := #NO_ERROR;\n\t\nEND_FUNCTION_BLOCK\n\n", "return_value": [], "ID": 22, "cot": "1. 定义一个函数块\"StackMin\"，包含输入、输出、输入/输出、变量、临时变量和常量部分。\n2. 输入部分包含push、pop和reset三个布尔型变量，分别用于控制入栈、出栈和复位操作。\n3. 输出部分包含error和status两个变量，分别用于表示是否发生错误和状态代码。\n4. 输入/输出部分包含item和stack两个变量，分别用于表示入栈或出栈的元素值和作为栈的数组。\n5. 在函数块的主体部分，根据输入的控制信号执行相应的操作，并更新输出的状态代码。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        push : Bool;    //入栈操作，在栈未满的情况下，将一个元素添加到栈内\n        pop : Bool;    //出栈操作，在栈不空的情况下，从栈内移除最小值元素，并返回该元素的值。\n        reset : Bool;    //复位操作，栈顶位置将被重置。\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR_IN_OUT\n        item : Int;    //用于入栈或从栈内返回的值\n        stack : Array[0..3] of Int;    //用于作为栈的数组\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "字符串转换为IP地址和端口号", "description": "在西门子PLC编程中，经常需要从用户输入或外部设备接收包含IP地址和端口号的字符串，并将其解析为相应的整数格式以便进行网络通信。\n编写一个函数FC，用于将包含IP地址和可能包含端口号的字符串转换为整数形式的IP地址和端口号。字符串的格式应为\"xxx.xxx.xxx.xxx[:port]\"，其中xxx代表0-255之间的数字，port代表0-65535之间的端口号（可选）。如果字符串包含端口号，则同时返回端口号；如果不包含，则返回默认的端口号（比如0）。把转换后的IP地址和端口号返回给系统数据类型TADDR_Param结构体的相应位置。\n函数应检查输入字符串是否符合\"IP_ADDRESS:PORT\"的格式要求，其中IP地址由四个用点分隔的0到255之间的整数组成，端口号为一个0到65535之间的整数。\n如果字符串格式正确，函数应将其解析为四个字节的整数数组表示的IP地址和一个整数表示的端口号，并将这些值返回。\n如果字符串格式不正确，函数应输出一个表示错误的状态和一个错误代码。\n状态代码：\n16#0000：执行FB没有出错\n16#811x：IP地址含有过多字符，其中x表示出错的最低字节序号，例如，IP地址的第2个字节有错，则x=2\n16#812x：IP地址字符串是空字符串，x表示的含义同上\n16#813x：超过IP地址最大值（255），x表示的含义同上\n16#8150：端口号字符过多\n16#8151：端口号字符串为空\n16#8152：超过端口号最大值（65535）", "type": "FUNCTION", "name": "StringToTaddr", "input": [{"name": "ipAddressString", "type": "String", "description": "输入的字符串"}], "output": [{"name": "error", "type": "Bool", "description": "FALSE: 没有发生错误; TRUE: 执行FB时出错"}, {"name": "status", "type": "Word", "description": "状态代码"}], "return_value": [{"type": "TADDR_Param", "description": "转换后的IP地址和端口号"}], "answer": "﻿FUNCTION \"StringToTaddr\" : TADDR_Param\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      ipAddressString : String;\n   END_VAR\n\n   VAR_OUTPUT \n      error : Bool;\n      status : Word;\n   END_VAR\n\n   VAR_TEMP \n      tempOctetIndex : Int;\n      tempCharPosition : Int;\n      tempAddressString : String;\n      tempOctetString : String[#MAX_CHAR_FOR_IP_OCTET_NUMBER];\n      tempNumber : UDInt;\n      tempPortNumberIsSpecified : Bool;\n      tempIpAdressTaddr  : TADDR_Param;\n   END_VAR\n\n   VAR CONSTANT \n      STATUS_FINISHED_NO_ERROR : Word := 16#0000;\n      ERR_OCTET_WRONG_NUMBER_OF_CHAR : Word := 16#8110;\n      ERR_OCTET_STRING_IS_EMPTY : Word := 16#8120;\n      ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS : Word := 16#8130;\n      ERR_PORT_WRONG_NUMBER_OF_CHAR : Word := 16#8150;\n      ERR_PORT_STRING_IS_EMPTY : Word := 16#8151;\n      ERR_PORT_EXCEEDS_MAX_PORT : Word := 16#8152;\n      MAX_IP_ADDRESS_OCTET_NUMBER : USInt := 255;\n      MAX_PORT_NUMBER : UInt := 65535;\n      EMPTY_STRING : Int := 0;\n      MAX_CHAR_FOR_IP_OCTET_NUMBER : Int := 4;\n      MAX_CHAR_FOR_PORT_NUMBER : Int := 5;\n      INIT_VAL : USInt := 0;\n      NUMBER_OF_IP_OCTETS : Int := 4;\n      CHAR_DOT : Char := '.';\n      CHAR_COLON : Char := ':';\n      CONVERT_FORMAT_TO_INTEGER : Word := 16#0000;\n      CONVERT_START_POSITION : UInt := 1;\n   END_VAR\n\n\nBEGIN\n\tREGION BLOCK INFO HEADER\n\t  //===============================================================================\n\t  // Title:            StringToTaddr\n\t  // Comment/Function: This function converts a string IP Address into TADDR Parameter format.\n\t  \n\t  //=============================================================================\n\tEND_REGION Block info header\n\t\n\tREGION Initialization\n\t  #tempAddressString := #ipAddressString;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[1] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[2] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[3] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_IP_ADDR[4] := #INIT_VAL;\n\t  #tempIpAdressTaddr.REM_PORT_NR := #INIT_VAL;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\tEND_REGION\n\t\n\tREGION Process Address String  \n\t  REGION Process octests 1-4\n\t    FOR #tempOctetIndex := 1 TO #NUMBER_OF_IP_OCTETS BY 1 DO\n\t      // check if loop has not reached the last octet\n\t      IF #tempOctetIndex < #NUMBER_OF_IP_OCTETS THEN\n\t        // search for dot as octet seperator\n\t        // there has to be a dot present between the octets\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_DOT);\n\t        \n\t      ELSE\n\t        // search for colon as port seperator after the last Octet\n\t        #tempCharPosition := FIND(IN1 := #tempAddressString, IN2 := #CHAR_COLON);\n\t        \n\t        // if colon is present, there is a port number specified / check if Port number added\n\t        #tempPortNumberIsSpecified := (#tempCharPosition > 0);\n\t        \n\t        // if no port is spezified, its just the last octet\n\t        IF NOT #tempPortNumberIsSpecified THEN\n\t          // need to set the char position to the end of string + one for later cobesion and checks\n\t          #tempCharPosition := LEN(#tempAddressString) + 1;\n\t        END_IF;\n\t      END_IF;\n\t      \n\t      REGION Octet conversion\n\t        // check if IP Octet contains more then three digits --> Error\n\t        IF #tempCharPosition > #MAX_CHAR_FOR_IP_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_WRONG_NUMBER_OF_CHAR OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // extract octet string\n\t        #tempOctetString := LEFT(IN := #tempAddressString, L := #tempCharPosition - 1);\n\t        // Check if Octet string is empty --> Error\n\t        IF LEN(#tempOctetString) = #EMPTY_STRING THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_STRING_IS_EMPTY OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // Convert the octet string to numerical value\n\t        STRG_VAL(IN     := #tempOctetString,\n\t                 FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t                 P      := #CONVERT_START_POSITION,\n\t                 OUT    => #tempNumber);\n\t        \n\t        // check if the octet number exeeds the maximum possible range of 255 of USInt --> Error\n\t        IF #tempNumber > #MAX_IP_ADDRESS_OCTET_NUMBER THEN\n\t          #error := TRUE;\n\t          #status := #ERR_OCTET_EXCEEDS_MAX_IP_ADDRESS OR INT_TO_WORD(#tempOctetIndex);\n\t          #StringToTaddr := #tempIpAdressTaddr;\n\t          RETURN;\n\t        END_IF;\n\t        \n\t        // add address octet to temp address tag\n\t        #tempIpAdressTaddr.REM_IP_ADDR[#tempOctetIndex] := UDINT_TO_USINT(#tempNumber);\n\t        \n\t        // delete octet string from address string\n\t        #tempAddressString := DELETE(IN := #tempAddressString, P := 1, L := #tempCharPosition);\n\t      END_REGION Octet conversion\n\t    END_FOR;\n\t  END_REGION Process octests 1-4\n\t  \n\t  REGION PORT number conversion\n\t    // If the string contains a port number too, parse it\n\t    IF #tempPortNumberIsSpecified THEN\n\t      // lenght of string exceeds length of port string --> Error\n\t      IF LEN(#tempAddressString) > #MAX_CHAR_FOR_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_WRONG_NUMBER_OF_CHAR;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t        \n\t        // Check if string is empty --> Error\n\t      ELSIF LEN(#tempAddressString) = #EMPTY_STRING THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_STRING_IS_EMPTY;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // Convert the port number string to numerical value\n\t      STRG_VAL(IN     := #tempAddressString,\n\t               FORMAT := #CONVERT_FORMAT_TO_INTEGER,\n\t               P      := #CONVERT_START_POSITION,\n\t               OUT    => #tempNumber);\n\t      \n\t      // check if the Port number exeeds the maximum possible range of 65535 of UInt --> Error\n\t      IF #tempNumber > #MAX_PORT_NUMBER THEN\n\t        #error := TRUE;\n\t        #status := #ERR_PORT_EXCEEDS_MAX_PORT;\n\t        #StringToTaddr := #tempIpAdressTaddr;\n\t        RETURN;\n\t      END_IF;\n\t      \n\t      // add port number to temp address tag\n\t      #tempIpAdressTaddr.REM_PORT_NR := UDINT_TO_UINT(#tempNumber);\n\t    END_IF;\n\t  END_REGION PORT number conversion\n\t  \n\tEND_REGION\n\t\n\tREGION Outputs\n\t  #error := FALSE;\n\t  #status := #STATUS_FINISHED_NO_ERROR;\n\t  #StringToTaddr := #tempIpAdressTaddr;\n\t  //ENO mechanism is not used - forced to true.\n\t  ENO := TRUE;\n\tEND_REGION\n\t\nEND_FUNCTION\n\n", "in/out": [], "ID": 23, "cot": "1. 定义变量和常量\n2. 检查输入字符串是否为空\n3. 检查IP地址部分是否符合格式要求\n4. 检查端口号部分是否符合格式要求\n5. 解析IP地址和端口号\n6. 返回结果\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        ipAddressString : String;    //输入的字符串\n    END_VAR\n\n    VAR_OUTPUT\n        error : Bool;    //FALSE: 没有发生错误; TRUE: 执行FB时出错\n        status : Word;    //状态代码\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
{"title": "温度逻辑控制", "description": "编写一个函数块FB，实现一个温度控制逻辑。该程序应包含以下功能：\n1. 通过模拟量输入模块读取温度传感器的值。\n2. 将读取的温度值TemperatureSensorInput与设定的温度值SetTemperature进行比较。\n3. 如果实际温度低于设定温度，则启动加热器HeaterOutput。\n4. 如果实际温度高于设定温度，则关闭加热器HeaterOutput。\n5. 如果加热器连续工作超过一定时间（为方便测试，采用5s），应触发过热保护，自动关闭加热器，必须再过一定时间（为方便测试，采用3s）才能解除过热保护。\n6. 提供状态指示，显示当前温度、设定温度、加热器状态以及是否有过热保护触发。\n7. 提供温度传感器故障判断，如果读取的温度值TemperatureSensorInput小于0或大于100，则认为传感器故障，此时应关闭加热器。", "type": "FUNCTION_BLOCK", "name": "TempCtrl", "input": [{"name": "TemperatureSensorInput", "type": "Real", "description": "温度传感器输入值，即实际温度"}, {"name": "SetTemperature", "type": "Real", "description": "设定温度值"}], "output": [{"name": "CurrentTemperature", "type": "Real", "description": "当前温度显示"}, {"name": "SetTempDisplay", "type": "Real", "description": "设定温度显示"}, {"name": "HeaterStatus", "type": "Bool", "description": "加热器状态显示"}, {"name": "OverheatProtection", "type": "Bool", "description": "过热保护状态显示"}], "in/out": [{"name": "HeaterOutput", "type": "Bool", "description": "加热器控制输出"}], "answer": "﻿FUNCTION_BLOCK \"TempCtrl\"\n{ S7_Optimized_Access := 'TRUE' }\n\n   VAR_INPUT \n      TemperatureSensorInput : Real;   // 温度传感器输入值\n      SetTemperature : Real;   // 设定温度值\n   END_VAR\n\n   VAR_OUTPUT \n      CurrentTemperature : Real;   // 当前温度显示\n      SetTempDisplay : Real;   // 设定温度显示\n      HeaterStatus : Bool;   // 加热器状态显示\n      OverheatProtection : Bool;   // 过热保护状态显示\n   END_VAR\n\n   VAR_IN_OUT \n      HeaterOutput : Bool;   // 加热器控制输出\n   END_VAR\n\n   VAR \n      HeaterState : Struct\n         IsEnabled : Bool;\n         OverheatProtectionTriggered : Bool;\n      END_STRUCT;\n      OverheatTimer  : TON_TIME;   // 过热保护定时器\n      SensorError : Bool;   // 传感器错误标志\n      CoolTimer  : TON_TIME;\n      OverheatTimerOutput  : Bool;\n      CoolTimerOutput  : Bool;\n   END_VAR\n\n\nBEGIN\n\t// 显示当前温度和设定温度 \n\t#CurrentTemperature := #TemperatureSensorInput;\n\t#SetTempDisplay := #SetTemperature;\n\t\n\t// 检查传感器是否失效 \n\tIF #TemperatureSensorInput < 0 OR #TemperatureSensorInput > 100 THEN\n\t    #SensorError := TRUE;\n\tELSE\n\t    #SensorError := FALSE;\n\tEND_IF;\n\t\n\t// 温度控制逻辑 \n\t// 过热保护逻辑 \n\t#OverheatTimer(IN := #HeaterOutput,\n\t               PT := T#5S,\n\t               Q => #OverheatTimerOutput);\n\tIF #HeaterState.IsEnabled AND #OverheatTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := TRUE;\n\t    #HeaterState.IsEnabled := FALSE;\n\t    #HeaterOutput := FALSE;\n\tEND_IF;\n\t#CoolTimer(IN := #HeaterState.OverheatProtectionTriggered,\n\t           PT := t#3S,\n\t           Q => #CoolTimerOutput);\n\tIF #CoolTimerOutput THEN\n\t    #HeaterState.OverheatProtectionTriggered := FALSE ;\n\tEND_IF;\n\t\n\tIF NOT #SensorError THEN\n\t    IF #CurrentTemperature < #SetTemperature AND NOT #HeaterState.OverheatProtectionTriggered THEN\n\t        IF NOT #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := TRUE;\n\t            #HeaterOutput := TRUE;\n\t        END_IF;\n\t    ELSIF #CurrentTemperature > #SetTemperature THEN\n\t        IF #HeaterState.IsEnabled THEN\n\t            #HeaterState.IsEnabled := FALSE;\n\t            #HeaterOutput := FALSE;\n\t        END_IF;\n\t    END_IF;\n\t    \n\tELSE\n\t    // 传感器错误处理 \n\t    #HeaterOutput := FALSE;\n\t    #HeaterState.IsEnabled := FALSE;\n\tEND_IF;\n\t\n\t// 显示加热器状态和过热保护状态 \n\t#HeaterStatus := #HeaterState.IsEnabled;\n\t#OverheatProtection := #HeaterState.OverheatProtectionTriggered;\nEND_FUNCTION_BLOCK\n\n", "return_value": [], "ID": 24, "cot": "1. 读取温度传感器的值。\n2. 将读取的温度值与设定的温度值进行比较。\n3. 根据比较结果控制加热器的开关。\n4. 实现过热保护功能。\n5. 提供状态指示。\n6. 提供温度传感器故障判断。\n\n", "is_sample": true, "var": "\n    VAR_INPUT\n        TemperatureSensorInput : Real;    //温度传感器输入值，即实际温度\n        SetTemperature : Real;    //设定温度值\n    END_VAR\n\n    VAR_OUTPUT\n        CurrentTemperature : Real;    //当前温度显示\n        SetTempDisplay : Real;    //设定温度显示\n        HeaterStatus : Bool;    //加热器状态显示\n        OverheatProtection : Bool;    //过热保护状态显示\n    END_VAR\n\n    VAR_IN_OUT\n        HeaterOutput : Bool;    //加热器控制输出\n    END_VAR\n\n    VAR \n        【】\n    END_VAR\n    \n    VAR_TEMP\n        【】\n    END_VAR\n    \n    VAR CONSTANT\n        【】\n    END_VAR"}
